<!DOCTYPE html>

<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta name="generator" content="Jekyll v3.3.1">

		<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Merriweather:400,400italic,700,700italic|Open+Sans:400,400italic,600,600italic,700,700italic|Inconsolata:400,700">
		<link rel="stylesheet" href="/css/main.css">
		<link rel="apple-touch-icon" href="/apple-touch-icon.png">
		<link rel="icon" type="image/png" href="/touch-icon.png" sizes="192x192">
		<link rel="icon" type="image/png" href="/images/favicon.png">

		<link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Autonomous Collective Systems Laboratory" />
		<!-- Begin Jekyll SEO tag v2.0.0 -->
<title>Setting Up Raspberry Pi with Camera for Pheeno - Autonomous Collective Systems Laboratory</title>
<meta property="og:title" content="Setting Up Raspberry Pi with Camera for Pheeno" />
<meta name="description" content="Unboxing, Formatting, and Installing the Operating System for the PiFirst, credit should be given where credit is due. Most of the networking information comes from A Raspberry Pi-Controlled Robot; Building a Rover with Python, Linux, Motors, and Sensors by Wolfram Donat. This was done on an older version of the Pi so some of the information have changed things here and there but the source of a lot of this information is from this book. It is a very good source for starting out in robotic control with a Raspberry Pi." />
<meta property="og:description" content="Unboxing, Formatting, and Installing the Operating System for the PiFirst, credit should be given where credit is due. Most of the networking information comes from A Raspberry Pi-Controlled Robot; Building a Rover with Python, Linux, Motors, and Sensors by Wolfram Donat. This was done on an older version of the Pi so some of the information have changed things here and there but the source of a lot of this information is from this book. It is a very good source for starting out in robotic control with a Raspberry Pi." />
<link rel="canonical" href="http://localhost:4000/pheeno/raspberry_pi_content/" />
<meta property="og:url" content="http://localhost:4000/pheeno/raspberry_pi_content/" />
<meta property="og:site_name" content="Autonomous Collective Systems Laboratory" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-06-12T21:49:01-04:00" />
<script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "Article",
    "headline": "Setting Up Raspberry Pi with Camera for Pheeno",
    "datePublished": "2017-06-12T21:49:01-04:00",
    "description": "Unboxing, Formatting, and Installing the Operating System for the PiFirst, credit should be given where credit is due. Most of the networking information comes from A Raspberry Pi-Controlled Robot; Building a Rover with Python, Linux, Motors, and Sensors by Wolfram Donat. This was done on an older version of the Pi so some of the information have changed things here and there but the source of a lot of this information is from this book. It is a very good source for starting out in robotic control with a Raspberry Pi.",
    "logo": "http://localhost:4000/siteicon.png",
    "url": "http://localhost:4000/pheeno/raspberry_pi_content/"
  }
</script>
<!-- End Jekyll SEO tag -->

		
        
        
	</head>

	<body>
		<header>
			<h1>
				<a href="/"><img src="/images/emblem.svg" width="40" height="40" alt="Autonomous Collective Systems Laboratory logo"></a>
				Autonomous Collective Systems Laboratory
				<button type="button" class="open-nav" id="open-nav"></button>
			</h1>

			<form action="/search/" method="get">
				<input type="text" name="q" id="search-input" placeholder="Search" autofocus>
				<input type="submit" value="Search" style="display: none;">
			</form>

			<nav class="full-navigation">
				<ul>
					<li class="nav-item top-level ">
						
						<a href="/">Welcome</a>
					</li>
				</ul>

				<ul>
					
					
						<li class="nav-item top-level ">
							
							<a href="/ROS/pheeno-ros-installation-guide/">ROS</a>
							<ul>
								
									<li class="nav-item "><a href="/ROS/pheeno-ros-installation-guide/">ROS Installation for Pheeno</a></li>
								
									<li class="nav-item "><a href="/ROS/pheeno-ros-guide/">pheeno_ros ROS Package Guide</a></li>
								
									<li class="nav-item "><a href="/ROS/pheeno-ros-server-guide/">pheeno_ros_server ROS Package Guide</a></li>
								
									<li class="nav-item "><a href="/ROS/pheeno-ros-sim-guide/">pheeno_ros_sim ROS Package Guide</a></li>
								
							</ul>
						</li>
					
						<li class="nav-item top-level ">
							
							<a href="/controls/pheeno-controller-guide/">Controls</a>
							<ul>
								
									<li class="nav-item "><a href="/controls/pheeno-controller-guide/">Controller for Pheeno Navigation</a></li>
								
									<li class="nav-item "><a href="/controls/pheeno-observer-guide/">Using Pheeno's for Reliable Feedback</a></li>
								
							</ul>
						</li>
					
						<li class="nav-item top-level current">
							
							<a href="/pheeno/pheeno_construction_content/">Pheeno</a>
							<ul>
								
									<li class="nav-item "><a href="/pheeno/pheeno_construction_content/">Pheeno Construction Guide</a></li>
								
									<li class="nav-item current"><a href="/pheeno/raspberry_pi_content/">Setting Up Raspberry Pi with Camera for Pheeno</a></li>
								
									<li class="nav-item "><a href="/pheeno/pheeno_software_installation/">Pheeno Software Installation</a></li>
								
									<li class="nav-item "><a href="/pheeno/pheeno_programming_content/">Beginning to Program Pheeno</a></li>
								
							</ul>
						</li>
					
				</ul>

				<ul>
					<li class="nav-item top-level ">
						
						<a href="/changelog/">Change Log</a>
					</li>
				</ul>
			</nav>
		</header>

		<section class="main">
			<div class="page-header">
				<h2>Pheeno</h2>
				<h3>Setting Up Raspberry Pi with Camera for Pheeno</h3>
			</div>
			<article class="content">
				<h2 id="unboxing-formatting-and-installing-the-operating-system-for-the-pi">Unboxing, Formatting, and Installing the Operating System for the Pi</h2>
<p>First, credit should be given where credit is due. Most of the networking information comes from <u>A Raspberry Pi-Controlled Robot; Building a Rover with Python, Linux, Motors, and Sensors</u> by Wolfram Donat. This was done on an older version of the Pi so some of the information have changed things here and there but the source of a lot of this information is from this book. It is a very good source for starting out in robotic control with a Raspberry Pi.</p>

<h3 id="formatting-the-sd-card-to-install-the-os-on-the-raspberry-pi">Formatting the SD card to install the OS on the Raspberry Pi</h3>
<p>The Raspberry Pi is essentially a Linux computer and will not work straight out of the box. We need to install an operating system that will run on-board the Pi. To do this we will need a micro SD card (4GB or larger, 8GB is preferred) and a SD card reader on your personal computer. Note, if your computer does not have a SD card reader you can easily find a USB adapter to plug into your machine.</p>

<p>A quick startup guide can be found <a href="https://www.raspberrypi.org/help/noobs-setup/">here</a>. If this link is down or you do not have access to this PDF on a computer, the process will be summarized below.</p>

<ol>
  <li>Insert the SD card into your computer. <font color="red">Note</font>: I did this on a Windows machine so I would recommend that route.</li>
  <li>Format the SD card to make sure it is clean and ready for the OS to be installed.
    <ol>
      <li>Download the SD Association’s formating tool (SD Formatter 4.0) from <a href="https://www.sdcard.org/downloads/formatter_4/">here</a> for the operating system you are using (Windows or Mac).</li>
      <li>Install and run the formatting tool.</li>
      <li>Check that the drive you have selected matches your SD card (it would be really unfortunate if you formatted a different drive and erased all those files.)</li>
      <li>Format the drive.</li>
    </ol>
  </li>
  <li>Download the New Out Of Box Software (NOOBS!) <a href="https://www.raspberrypi.org/downloads/">here</a>.</li>
  <li>Extract the files in the NOOBS Zip you downloaded to the formatted SD card.</li>
  <li>Eject the SD card from your computer after the files have finished transferring and plug it into the Raspberry Pi.</li>
  <li>Hook the Raspberry Pi up to a keyboard, mouse, and monitor. Then insert the USB power cable to turn the Pi on. The Pi should now boot into NOOBS and display a list of operating systems. If it doesn’t you did something wrong with the formatting or file copy go back and reformat the SD! If this works, <font color="magenta">FANTASTIC</font>, that little board is now a fully functioning computer!</li>
  <li>There should be a list of operating systems you can install. Click Raspbian (the tick box next to the icon should have an x in it). Now click install.</li>
  <li>Go grab a drink or some food! The operating system is now installing. This can take a while (about 20 minutes).</li>
  <li>When the install process is completed the Raspberry Pi configuration menu (raspi-config) will load. Here you are able to set the time and date for your region and enable a Raspberry Pi camera board, or even create users. We can access this at a later date to make changes as we need but for now let’s just enable the camera!</li>
  <li>Upon rebooting, it will boot straight to the command line requesting a login. The default username and password are <strong>pi</strong> and <strong>raspberry</strong> respectively.  <font color="red">Note</font>: you will not see any writing appear when you type the password. This is a standard linux security feature.</li>
  <li>To start the graphical interface (desktop) type startx.</li>
</ol>

<h3 id="making-sure-the-camera-works">Making Sure the Camera Works!</h3>
<p>Again, a great guide with video is <a href="https://www.raspberrypi.org/help/camera-module-setup/">here</a>. Again below will summarize the steps to making sure the camera works!</p>

<p>First let’s physically install the camera board.<em><font color="red">Make sure your Pi is off when installing!</font></em> The flex cable has gray connector strips on the back side. Behind the Ethernet port is a black plastic connector this goes into. Lift the plastic tabs on the side of this connector to unlock the connector. Insert the flex cable so the tin connectors are facing away from the ethernet port and are level. Push the plastic tabs back down so the wire is locked in place. When done, the setup should look like Figure <a href="raspberry_pi_content#fig1">1</a>. Great now the camera is physically installed!</p>

<figure id="fig1">
    <center>
        <img src="http://localhost:4000/images/raspberry_pi/installCamera.jpg" width="750" height="500" />
    </center>
</figure>
<p><strong><em>Figure 1:</em></strong> <em>Raspberry Pi with camera board installed.</em></p>

<p>Now we can fully connect the Raspberry Pi again. Make sure it is connected to the internet by plugging in an ethernet chord or connecting via wifi. When it boots open the command terminal and upgrade the firmware to the latest version through the commands:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>sudo apt-get update
sudo apt-get upgrade
</code></pre>
</div>

<p>Now we will let the Pi know we want it to use the camera pins. In the command terminal type:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>sudo raspi-config
</code></pre>
</div>

<p>to bring up the configuration settings for the Pi. Go to the <em>Enable Camera</em> option. Choose the enable option. Select finish and reboot the Pi! Now everything should be ready to take a picture so lets try! First, go to the graphical user interface (type <em>startx</em> at the terminal).  To test it open the command terminal (seen in Figure <a href="raspberry_pi_content#fig2">2</a>) and type:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>raspivid -t 10000
</code></pre>
</div>

<figure id="fig2">
    <center>
        <img src="http://localhost:4000/images/raspberry_pi/terminal.png" width="500" height="500" />
    </center>
</figure>
<p><strong><em>Figure 2:</em></strong> <em>Raspberry Pi graphical user interface with LXTerminal highlighted.</em></p>

<p>This should have displayed a picture on the monitor for 10 seconds (note the units of the argument after the -t are in ms). Hopefully it all worked!</p>

<h2 id="installing-software-and-vnc">Installing Software and VNC</h2>
<p>In this section we will set up a VNC (Virtual Network Computing) server in order to access the graphical user interface of the Pi remotely instead of constantly having to hook it up to a monitor. We will auto configure the wifi so the pi is connected to a network (not necessarily one with internet connection!). <em><font color="red">Make sure a WiFi dongle is plugged into a USB port on the Pi!</font></em>  We will also install some other supplemental software needed for image processing.  <em><font color="red">If you do not know how to hook up the Pi to an internet network it is detailed below but you still need to access the internet for updates/upgrades so either skip to the GUI network configuration first or plug in an ethernet cord to get the Pi online!</font></em></p>

<h3 id="setting-up-the-wifi-connection">Setting Up the WiFi Connection</h3>
<p>It is important to note unlike a standard Windows, Linux, or Mac operating system, <em><font color="red">Raspbian does not notify you of updates</font></em>. Thus, it is a good habit to force your Pi to look for updates whenever installing new software (ideally daily but that may be overkill). Thus before doing anything bring up the terminal and update and upgrade the Pi through the commands:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>sudo apt-get update
sudo apt-get upgrade
</code></pre>
</div>

<p>Now, we can configure the network through the terminal or the GUI, I will outline both below.</p>

<h4 id="terminal-network-set-up">Terminal Network Set-Up</h4>
<p>Once the upgrade is complete, first install <em>wpasupplicant</em> (<font color="red">Note</font>: This may already be installed).</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>sudo apt-get install wpasupplicant
</code></pre>
</div>

<p>You may get a message saying <em>wpasupplicant</em> is already in the newest version, that is fine. Once it is installed use any text editor to open the network config file (here we use nano which will open it in the terminal):</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>sudo nano /etc/wpa_supplicant/wpa_supplicant.conf
</code></pre>
</div>

<p>Here is where you put the network information. Leave the first two lines of the file as they are, then add:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>network={
    ssid="_your network id_"
    psk="_your network key_"
    proto=WPA
    key_mgmt=WPA-PSK
    pairwise=TKIP
    authalg=OPEN
}
</code></pre>
</div>

<p>Replace <strong>“<em>your network id</em>“</strong> and <strong>“<em>your network key</em>“</strong> with your network name and key (the network key is the password that has been set on the network to log into it from any device). It should be noted, if you care about security, this does leave your network name and key in a plain text file for any half-decent hacker to find and use.</p>

<p>Save the file and reboot your Pi for the changes to take place.</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>sudo shutdown -r now
</code></pre>
</div>

<p>When the Pi reboots, you should have a wireless connection!</p>

<h4 id="gui-network-set-up">GUI Network Set-UP</h4>
<p>In the top right of the desktop of the Pi you will see a wifi icon. Click it, choose your network you want to connect to and enter the passkey! Easy as that (but not quite as cool as editing a config file right?!).</p>

<h3 id="check-connection">Check Connection</h3>
<p>Now to make sure the Pi is connected to the internet bring up the terminal and type:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>ifconfig
</code></pre>
</div>

<p>This displays all your internet connections! You should see three connections listed eth0, lo, and wlan0. Eth0 is your ethernet cable connection if you have one, wlan0 is the one that should have just been configured. If there is an IP address <font color="magenta">WOO HOO</font> the Pi is connected to the internet. To make sure try connecting to your favorite web page (if your network has an internet connection and isn’t a LAN)</p>

<h3 id="creating-a-static-ip-on-the-network">Creating a Static IP on the Network</h3>
<p>In order to connect to your Pi you must know it’s “name”. Imagine your Pi as another person. If you want to get their attention from across the room you typically have to yell their name. This is where a Static IP address comes in! Think of a Pi’s IP address as its name (this is true for any network device). The funny thing about computers on a network is they can change their IP address whenever they connect, thus we have to set the Pi’s IP address so when we try to connect to it we call it the right “name” to get its attention. If you don’t care for this metaphor you are going to have to do this anyway!</p>

<p>First we need some information about your connection. In the terminal enter:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>ifconfig
</code></pre>
</div>

<p>Again this should list some connection information, eth0, lo, wlan0. We are attempting to create a static IP on the wireless network thus take note of several details about the wlan0. We are interested in (write these down!),</p>

<ul>
  <li><strong><em>inet addr</em></strong> - the Pi’s current IP address.</li>
  <li><strong><em>Bcast</em></strong> - the broadcast IP range.</li>
  <li><strong><em>Mask</em></strong> - the subnet mask address.</li>
</ul>

<p>We need a little more information to finish this up. So now, in the terminal, enter,</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>netstat-nr
</code></pre>
</div>
<p>We are interested in (write down the ones that are not 0.0.0.0),</p>

<ul>
  <li><strong><em>Gateway</em></strong></li>
  <li><strong><em>Destination</em></strong></li>
</ul>

<p>Now the config file can finally be edited to gives a static IP! Let’s open it to be edited in the terminal by entering,</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>sudo nano /etc/network/interfaces
</code></pre>
</div>
<p>You should get something that looks like this,</p>

<div class="highlighter-rouge"><pre class="highlight"><code>auto lo
iface lo inet loopback

auto eth0
allow-hotplug eth0
iface eth0 inet manual

auto wlan0
allow-hotplug wlan0
iface eth0 inet manual
wpa-config /etc/wpa_supplicant/wpa_supplicant.conf
</code></pre>
</div>

<p>It may have some additional entries but that should be what it looks like for the most part. Again, if you are worried about security, the wpa_supplicant.conf has the network information and password in a plain text file that can be read very easily.</p>

<p>Now let’s enter the information for our static IP! Edit the file so that it looks like this!</p>

<div class="highlighter-rouge"><pre class="highlight"><code>auto lo
iface lo inet loopback

auto eth0
allow-hotplug eth0
iface eth0 inet manual

auto wlan0
allow-hotplug wlan0
iface eth0 inet static
address ”_the static IP address_”
netmask ”_the netmask found above_”
network ”_the network found above_”
broadcast ”_the broadcast found above_”
gateway ”_the gateway found above_”
wpa-config /etc/wpa_supplicant/wpa_supplicant.conf
</code></pre>
</div>

<p>Exit and save the file! Now reboot the Pi,</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>sudo shutdown -r now
</code></pre>
</div>

<p>To see if everything worked open the terminal and type,</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>ifconfig
</code></pre>
</div>

<p>Under wlan0 the IP address should be the one you set! Now to test the connection type,</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>ping <span class="s2">"_the gateway found above_"</span>
</code></pre>
</div>

<p>If everything if configured correctly you should get a few printouts that read,</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>64 bites from ”_the gateway found above_”: icmp_req:1 <span class="nv">ttl</span><span class="o">=</span>64 <span class="nb">time</span><span class="o">=</span>1.24ms
</code></pre>
</div>

<p>If all of that works <font color="magenta">CONGRATS</font> you have now set a static IP! We will soon be able to access the Pi remotely!</p>

<h3 id="setting-up-secure-shell-ssh-and-virtual-network-computing-vnc">Setting Up Secure Shell (SSH) and Virtual Network Computing (VNC)</h3>
<h4 id="ssh">SSH</h4>
<p>Secure Shell allows us to remotely log into the raspberry pi but only in a terminal setting. However, you will notice everything we have done has been through the terminal so this is invaluable. We will first enable this on the Pi! In the terminal enter,</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>sudo raspi-config
</code></pre>
</div>

<p>Under <font color="red">Advanced Options</font> select SSH and enable. That’s it! Now onto your PC. For SSH I use Putty to connect (on windows). Putty can be downloaded <a href="http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html">here</a>. Now simply run it and enter the static IP address you created earlier! It should prompt you with,</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>login as: <span class="s2">"_the username for the pi (default is pi)_"</span>
pi@: <span class="s2">"_the IP address of the Pi_"</span> password: <span class="s2">"_the password for the pi (default is raspberry)_"</span>
</code></pre>
</div>
<p>Now you should be logged into the terminal of the Pi! <font color="red">Note</font>: This can be done on Linux as well by using the command,</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>ssh -l pi <span class="s2">"_the IP address of the Pi_"</span>
</code></pre>
</div>

<h4 id="vnc">VNC</h4>
<p>Virtual Network Computing (VNC) is useful for those less Linux savy. It allows for the user to see the desktop of the Pi instead of the terminal. The terminal and other programs may still be accessed like you were logged straight into the Pi. However, some things, like video streams, might not work as if you were hooked straight into the machine. This is simple enough to install. On the Pi open the terminal and enter,</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>sudo apt-get install tightvncserver
</code></pre>
</div>

<p>This installs TightVNC, which is possibly the easiest VNC package to get running. Once it is installed you can start the server with a command line,</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>vncserver :1 -geometry 1024x768 -depth 16
</code></pre>
</div>

<p>On your personal computer install a VNC client. I recommend realVNC found <a href="http://www.realvnc.com/download/">here</a>. You may have to enter some information for a free key which is good for 5 computers. To connect to the Pi through VNC enter,</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="s2">"_the IP address of the PI_"</span>:1
</code></pre>
</div>

<p>You can get this to start on boot. However, it is probably better to ssh in and start the server when needed.</p>

<h3 id="setting-up-an-ad-hoc-network">Setting Up an Ad Hoc Network</h3>
<p>Now let’s pretend we don’t live in a perfect world where we always have a network connection we can talk to each other through. What if we’re bringing Pheeno out to an unknown environment or to some school outreach event? What if we don’t have a network to connect to the Raspberry Pi through? Are we finished?! Fear not for the Raspberry Pi can become a server of an Ad Hoc Network! <font color="red">We don't want to do this unless we are taking Pheeno (or the Raspberry Pi) out of the lab</font>.</p>

<p>Once again we have to edit the interfaces file! I would <em><font color="red">STRONGLY</font></em> recommend making two files saved somewhere. One for when you are in the lab, and one when you are in the field. None the less again we must edit the interfaces file,</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>sudo nano /etc/network/interfaces
</code></pre>
</div>

<p>We want to edit the wireless section again so it looks like the following,</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>auto wlan0
iface wlan0 inet static
address <span class="s2">"_some IP address (192.168.119.1)_"</span>
netmask <span class="s2">"_some netmask (255.255.255.0)_"</span>
wireless-channel 1
wireless-essid <span class="s2">"_some name for the broad casted network_"</span>
wireless-mode ad-hoc
</code></pre>
</div>

<p>Save the file and exit. Then restart the wireless connection,</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>sudo ifdown wlan0
sudo ifup wlan0
</code></pre>
</div>

<p>Now you should be able to see the network being broadcast. <font color="red">Do not connect to it</font>. It is not ready to receive connections. It is simply broadcasting it’s ad-hoc network but will not assign IP addresses to any computer connecting to it. We need to set up the Pi to assign IP addresses. First we will install isc-dhcp-server,</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>sudo apt-get install isc-dhcp-server
</code></pre>
</div>

<p>Now we have to edit the config file to get it to work! Open the config file with the command,</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>sudo nano /etc/dhcp/dhcpd.conf
</code></pre>
</div>

<p>There is a TON of stuff in this file. You want the only uncommented lines to be (changes in <font color="red">red</font>),</p>

<div class="highlighter-rouge"><pre class="highlight"><code>ddns-update-style interim;
default-lease-time 600;
max-lease-time 7200;
authoritative;
log-facility local7;
subnet "_some subnet similar to the IP address (192.168.119.0)_" netmask "_some netmask (255.255.255.0)_" {
    range "_some range of assignable IP address (192.168.119.5 192.168.119.100)_";
}
</code></pre>
</div>

<p>Here is an example of what it may look like,</p>

<div class="highlighter-rouge"><pre class="highlight"><code>#
# Sample configuration file for ISC dhcpd for Debian
#
#

# The ddns-updates-style parameter controls whether or not the server will
# attempt to do a DNS update when a lease is confirmed. We default to the
# behavior of the version 2 packages ('none', since DHCP v2 didn't
# have support for DDNS.)
ddns-update-style interim;

# option definitions common to all supported networks...
#option domain-name "example.org";
#option domain-name-servers ns1.example.org, ns2.example.org;

default-lease-time 600;
max-lease-time 7200;

# If this DHCP server is the official DHCP server for the local
# network, the authoritative directive should be uncommented.
authoritative;

# Use this to send dhcp log messages to a different log file (you also
# have to hack syslog.conf to complete the redirection).
log-facility local7;

# No service will be given on this subnet, but declaring it helps the
# DHCP server to understand the network topology.

#subnet 10.152.187.0 netmask 255.255.255.0 {
#}

# This is a very basic subnet declaration.
subnet 192.168.119.0 netmask 255.255.255.0 {
range 192.168.119.5 192.168.119.100;
}
#subnet 10.254.239.0 netmask 255.255.255.224 {
#  range 10.254.239.10 10.254.239.20;
#  option routers rtr-239-0-1.example.org, rtr-239-0-2.example.org;
#}

# This declaration allows BOOTP clients to get dynamic addresses,
# which we don't really recommend.

#subnet 10.254.239.32 netmask 255.255.255.224 {
#  range dynamic-bootp 10.254.239.40 10.254.239.60;
#  option broadcast-address 10.254.239.31;
#  option routers rtr-239-32-1.example.org;
#}

# A slightly different configuration for an internal subnet.
#subnet 10.5.5.0 netmask 255.255.255.224 {
#  range 10.5.5.26 10.5.5.30;
#  option domain-name-servers ns1.internal.example.org;
#  option domain-name "internal.example.org";
#  option routers 10.5.5.1;
#  option broadcast-address 10.5.5.31;
#  default-lease-time 600;
#  max-lease-time 7200;
#}

# Hosts which require special configuration options can be listed in
# host statements.   If no address is specified, the address will be
# allocated dynamically (if possible), but the host-specific information
# will still come from the host declaration.

#host passacaglia {
#  hardware ethernet 0:0:c0:5d:bd:95;
#  filename "vmunix.passacaglia";
#  server-name "toccata.fugue.com";
#}

# Fixed IP addresses can also be specified for hosts.   These addresses
# should not also be listed as being available for dynamic assignment.
# Hosts for which fixed IP addresses have been specified can boot using
# BOOTP or DHCP.   Hosts for which no fixed address is specified can only
# be booted with DHCP, unless there is an address range on the subnet
# to which a BOOTP client is connected which has the dynamic-bootp flag
# set.
#host fantasia {
#  hardware ethernet 08:00:07:26:c0:a5;
#  fixed-address fantasia.fugue.com;
#}

# You can declare a class of clients and then do address allocation
# based on that.   The example below shows a case where all clients
# in a certain class get addresses on the 10.17.224/24 subnet, and all
# other clients get addresses on the 10.0.29/24 subnet.

#class "foo" {
#  match if substring (option vendor-class-identifier, 0, 4) = "SUNW";
#}

#shared-network 224-29 {
#  subnet 10.17.224.0 netmask 255.255.255.0 {
#    option routers rtr-224.example.org;
#  }
#  subnet 10.0.29.0 netmask 255.255.255.0 {
#    option routers rtr-29.example.org;
#  }
#  pool {
#    allow members of "foo";
#    range 10.17.224.10 10.17.224.250;
#  }
#  pool {
#    deny members of "foo";
#    range 10.0.29.10 10.0.29.230;
#  }
#}
</code></pre>
</div>

<h3 id="python-and-opencv">Python and OpenCV</h3>
<p>Pheeno uses OpenCV for its image processing and I have chosen to code in Python (as C/C++ get too messy for me). To finish the set up for the Pi let’s install OpenCV for python and make sure it runs. Again make sure the firmware is updated and upgraded,</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>sudo apt-get update
sudo apt-get upgrade
</code></pre>
</div>

<p>Now we will grab the libraries for OpenCV.</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>sudo apt-get install libopencv-dev python-opencv python-picamera -y
</code></pre>
</div>

<p>To test whether everything is working properly let’s create a quick python code with OpenCV to display some windows with the camera feed and mess with their colors! Make a new python code and save it in the home folder as <em><font color="red">cameraDisplay.py</font></em>. Open this empty file and fill it with,</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">picamera</span>
<span class="kn">import</span> <span class="nn">picamera.array</span>
<span class="kn">import</span> <span class="nn">cv2</span>

<span class="c">#CAMERA ROUTINE!</span>
<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
	<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">PiRGBArray</span><span class="p">(</span><span class="n">camera</span><span class="p">)</span> <span class="k">as</span> <span class="n">stream</span><span class="p">:</span>
		<span class="n">camera</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="p">(</span><span class="mi">640</span><span class="p">,</span><span class="mi">480</span><span class="p">)</span>

		<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
			<span class="n">camera</span><span class="o">.</span><span class="n">capture</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span><span class="s">'bgr'</span><span class="p">,</span><span class="n">use_video_port</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
			<span class="c">#stream.array contains the image array in bgr order!</span>
			<span class="n">gray</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2GRAY</span><span class="p">)</span>
			<span class="n">HSV</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2HSV</span><span class="p">)</span>
			<span class="n">cv2</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="s">'Video!'</span><span class="p">,</span> <span class="n">stream</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
			<span class="n">cv2</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="s">'GRAY!'</span><span class="p">,</span> <span class="n">gray</span><span class="p">)</span>
			<span class="n">cv2</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="s">'HSV!'</span><span class="p">,</span> <span class="n">HSV</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">cv2</span><span class="o">.</span><span class="n">waitKey</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span> <span class="o">==</span> <span class="nb">ord</span><span class="p">(</span><span class="s">'q'</span><span class="p">):</span>
				<span class="k">break</span>
			<span class="c">#reset the array for next capture</span>
			<span class="n">stream</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
			<span class="n">stream</span><span class="o">.</span><span class="n">truncate</span><span class="p">()</span>

		<span class="n">cv2</span><span class="o">.</span><span class="n">destroyAllWindows</span><span class="p">()</span>
</code></pre>
</div>

<p>To run it open the terminal and enter,</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>python cameraDisplay.py
</code></pre>
</div>

<p>Three windows should pop up and show the camera feed with different color schemes (RGB, Gray Scale, and HSV). If that works, <font color="magenta">YOU'RE DONE</font>! The Pi should be ready to go and be used however you see fit!</p>

			</article>
		</section>

		<script>
			document.getElementById("open-nav").addEventListener("click", function () {
				document.body.classList.toggle("nav-open");
			});
		</script>
	</body>
</html>
