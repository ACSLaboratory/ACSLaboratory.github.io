<!DOCTYPE html>

<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta name="generator" content="Jekyll v3.3.1">

		<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Merriweather:400,400italic,700,700italic|Open+Sans:400,400italic,600,600italic,700,700italic|Inconsolata:400,700">
		<link rel="stylesheet" href="/css/main.css">
		<link rel="apple-touch-icon" href="/apple-touch-icon.png">
		<link rel="icon" type="image/png" href="/touch-icon.png" sizes="192x192">
		<link rel="icon" type="image/png" href="/images/favicon.png">

		<link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Autonomous Collective Systems Laboratory" />
		<!-- Begin Jekyll SEO tag v2.0.0 -->
<title>Search - Autonomous Collective Systems Laboratory</title>
<meta property="og:title" content="Search" />
<meta name="description" content="Product documentation template for Jekyll." />
<meta property="og:description" content="Product documentation template for Jekyll." />
<link rel="canonical" href="http://localhost:4000/search/" />
<meta property="og:url" content="http://localhost:4000/search/" />
<meta property="og:site_name" content="Autonomous Collective Systems Laboratory" />
<script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "WebPage",
    "headline": "Search",
    "description": "Product documentation template for Jekyll.",
    "logo": "http://localhost:4000/siteicon.png",
    "url": "http://localhost:4000/search/"
  }
</script>
<!-- End Jekyll SEO tag -->

		
        
        
	</head>

	<body>
		<header>
			<h1>
				<a href="/"><img src="/images/emblem.svg" width="40" height="40" alt="Autonomous Collective Systems Laboratory logo"></a>
				Autonomous Collective Systems Laboratory
				<button type="button" class="open-nav" id="open-nav"></button>
			</h1>

			<form action="/search/" method="get">
				<input type="text" name="q" id="search-input" placeholder="Search" autofocus>
				<input type="submit" value="Search" style="display: none;">
			</form>

			<nav class="full-navigation">
				<ul>
					<li class="nav-item top-level ">
						
						<a href="/">Welcome</a>
					</li>
				</ul>

				<ul>
					
					
						<li class="nav-item top-level ">
							
							<a href="/ROS/pheeno-ros-installation-guide/">ROS</a>
							<ul>
								
									<li class="nav-item "><a href="/ROS/pheeno-ros-installation-guide/">ROS Installation for Pheeno</a></li>
								
									<li class="nav-item "><a href="/ROS/pheeno-ros-guide/">pheeno_ros ROS Package Guide</a></li>
								
									<li class="nav-item "><a href="/ROS/pheeno-ros-server-guide/">pheeno_ros_server ROS Package Guide</a></li>
								
									<li class="nav-item "><a href="/ROS/pheeno-ros-sim-guide/">pheeno_ros_sim ROS Package Guide</a></li>
								
							</ul>
						</li>
					
						<li class="nav-item top-level ">
							
							<a href="/controls/pheeno-controller-guide/">Controls</a>
							<ul>
								
									<li class="nav-item "><a href="/controls/pheeno-controller-guide/">Controller for Pheeno Navigation</a></li>
								
									<li class="nav-item "><a href="/controls/pheeno-observer-guide/">Using Pheeno's for Reliable Feedback</a></li>
								
							</ul>
						</li>
					
						<li class="nav-item top-level ">
							
							<a href="/pheeno/pheeno_construction_content/">Pheeno</a>
							<ul>
								
									<li class="nav-item "><a href="/pheeno/pheeno_construction_content/">Pheeno Construction Guide</a></li>
								
									<li class="nav-item "><a href="/pheeno/raspberry_pi_content/">Setting Up Raspberry Pi with Camera for Pheeno</a></li>
								
									<li class="nav-item "><a href="/pheeno/pheeno_software_installation/">Pheeno Software Installation</a></li>
								
									<li class="nav-item "><a href="/pheeno/pheeno_programming_content/">Beginning to Program Pheeno</a></li>
								
							</ul>
						</li>
					
				</ul>

				<ul>
					<li class="nav-item top-level ">
						
						<a href="/changelog/">Change Log</a>
					</li>
				</ul>
			</nav>
		</header>

		<section class="main">
			<div class="page-header">
				<h2>Autonomous Collective Systems Laboratory</h2>
				<h3>Search</h3>
			</div>
			<article class="content">
				<p><span id="search-process">Loading</span> results <span id="search-query-container" style="display: none;">for "<strong id="search-query"></strong>"</span></p>
<ul id="search-results"></ul>

<script>
	window.data = {
		
			
				
					
					

					"ros-pheeno-ros-guide": {
						"id": "ros-pheeno-ros-guide",
						"title": "pheeno_ros ROS Package Guide",
						"category": "",
						"url": " /ROS/pheeno-ros-guide/",
						"content": "Introduction The following guide will give a brief introduction to the use of the Robot Operating System with a single or multiple Pheenos. Arduino Code Once ROS is installed on the Pheeno, we can begin to set up the Pheeno to work with ROS. First, we need to upload the proper Arduino srcipt shown below. #include &lt;ArduinoHardware.h&gt; #include &lt;ros.h&gt; #include &lt;std_msgs Float32.h&gt; #include &lt;std_msgs Int16.h&gt; #include &lt;geometry_msgs Twist.h&gt; #include \"PheenoV2Basic.h\" Create ROS Node instance ros::NodeHandle nh; Create Pheeno Instance PheenoV2Basic pheeno_robot = PheenoV2Basic(2); Create Messages for Publishers std_msgs::Float32 scan_center_msg; std_msgs::Float32 scan_back_msg; std_msgs::Float32 scan_right_msg; std_msgs::Float32 scan_left_msg; std_msgs::Float32 scan_cr_msg; std_msgs::Float32 scan_cl_msg; std_msgs::Int16 encoder_LL_msg; Left HBridge, Left Motor Encoder std_msgs::Int16 encoder_LR_msg; Left HBridge, Right Motor Encoder std_msgs::Int16 encoder_RL_msg; Right HBridge, Left Motor Encoder std_msgs::Int16 encoder_RR_msg; Right HBridge, Right Motor Encoder Create Variables for Storing Motion Data int linear = 0; Forward and Backward motion. int angular = 0; Turning (Right and Left) motion. Create Publishers ros::Publisher pub_ir_center(\" scan_center\", &amp;scan_center_msg); Center IR ros::Publisher pub_ir_back(\" scan_back\", &amp;scan_back_msg); Back IR ros::Publisher pub_ir_right(\" scan_right\", &amp;scan_right_msg); Right IR ros::Publisher pub_ir_left(\" scan_left\", &amp;scan_left_msg); Left IR ros::Publisher pub_ir_cr(\" scan_cr\", &amp;scan_cr_msg); Center Right IR ros::Publisher pub_ir_cl(\" scan_cl\", &amp;scan_cl_msg); Center Left IR ros::Publisher pub_encoder_LL(\" encoder_LL\", &amp;encoder_LL_msg); Encoder LL ros::Publisher pub_encoder_LR(\" encoder_LR\", &amp;encoder_LR_msg); Encoder LR ros::Publisher pub_encoder_RL(\" encoder_RL\", &amp;encoder_RL_msg); Encoder RL ros::Publisher pub_encoder_RR(\" encoder_RR\", &amp;encoder_RR_msg); Encoder RR Callback for cmd_vel Subscriber. The following callback recieves a command in terms of m s. This will have to be converted into a binary output between 0-255. void callback(const geometry_msgs::Twist &amp;msg) { if (msg.linear.x &gt; 0 || msg.linear.x &lt; 0) { linear = 2550 * msg.linear.x; angular = 0; } else if (msg.linear.x == 0) { linear = 0; } if (msg.angular.z &gt; 0 || msg.angular.z &lt; 0) { linear = 0; angular = 2550 * msg.angular.z; } else if (msg.angular.z == 0) { angular = 0; } } Create Subscribers ros::Subscriber&lt;geometry_msgs::Twist&gt; sub_cmd_vel(\"cmd_vel\", callback); void setup() { Setup Pheeno robot pheeno_robot.SetupBasic(); Initialize ROS Node nh.initNode(); Start Advertising nh.advertise(pub_ir_center); nh.advertise(pub_ir_back); nh.advertise(pub_ir_right); nh.advertise(pub_ir_left); nh.advertise(pub_ir_cr); nh.advertise(pub_ir_cl); nh.advertise(pub_encoder_LL); nh.advertise(pub_encoder_LR); nh.advertise(pub_encoder_RL); nh.advertise(pub_encoder_RR); Start Subscribing nh.subscribe(sub_cmd_vel); } void loop() { Refresh Sensor Readings pheeno_robot.readIR(); pheeno_robot.readEncoders(); Assign sensor values to Msg variable scan_center_msg.data = pheeno_robot.CDistance; scan_back_msg.data = pheeno_robot.BDistance; scan_right_msg.data = pheeno_robot.RDistance; scan_left_msg.data = pheeno_robot.LDistance; scan_cr_msg.data = pheeno_robot.RFDistance; scan_cl_msg.data = pheeno_robot.LFDistance; encoder_LL_msg.data = pheeno_robot.encoderCountLL; encoder_LR_msg.data = pheeno_robot.encoderCountLR; encoder_RL_msg.data = pheeno_robot.encoderCountRL; encoder_RR_msg.data = pheeno_robot.encoderCountRR; Publish the Topics pub_ir_center.publish(&amp;scan_center_msg); pub_ir_back.publish(&amp;scan_back_msg); pub_ir_right.publish(&amp;scan_right_msg); pub_ir_left.publish(&amp;scan_left_msg); pub_ir_cr.publish(&amp;scan_cr_msg); pub_ir_cl.publish(&amp;scan_cl_msg); pub_encoder_LL.publish(&amp;encoder_LL_msg); pub_encoder_LR.publish(&amp;encoder_LR_msg); pub_encoder_RL.publish(&amp;encoder_RL_msg); pub_encoder_RR.publish(&amp;encoder_RR_msg); if (linear != 0) { if (linear &gt; 0) { PheenoMoveForward(linear); } else { PheenoMoveReverse(linear); } } else if (angular != 0) { if (angular &gt; 0) { PheenoTurnLeft(angular); } else { PheenoTurnRight(angular); } } else { pheeno_robot.brakeAll(); } nh.spinOnce(); delay(100); Required because the Teensy sends messages too fast. } Turns the Pheeno left. Currently the appropriate use is just by providing a speed between 0-255, without any error handling. Be careful! void PheenoTurnLeft(int speed) { pheeno_robot.reverseRL(speed); pheeno_robot.forwardLR(speed); } Turns the Pheeno Right. Currently, the appropriate use is just by providing a speed between 0-255, without any error handling. Be careful! void PheenoTurnRight(int speed) { pheeno_robot.reverseLR(speed); pheeno_robot.forwardRL(speed); } Moves the Pheeno Forward. Applying a specific speed value (0-255) and both motors will apply the speed without error handling. Be careful! void PheenoMoveForward(int speed) { pheeno_robot.forwardLR(speed); pheeno_robot.forwardRL(speed); } Moves the Pheeno Reverse. Applying a specific speed value (0-255) and both motors will apply the speed without error handling. Be careful! void PheenoMoveReverse(int speed) { pheeno_robot.reverseLR(speed); pheeno_robot.reverseRL(speed); } We will go through the relevant parts of this Arduino script to help familiarize yourselves with how rosserial_arduino programs work. In our case, the Arduino script will function as a node that will subscribe to a cmd_vel input while simultaneously publishing encoder and IR sensor values. Include Statements #include &lt;ArduinoHardware.h&gt; #include &lt;ros.h&gt; These two include statements are required to use ROS with the Arduino Teensy. It contains packages for defining Nodes, Publishers, and Subscribers. #include &lt;std_msgs Float32.h&gt; #include &lt;std_msgs Int16.h&gt; #include &lt;geometry_msgs Twist.h&gt; The next three include statements are for the message types we wish to use within this script. Currently, the IR Sensors are published with the Float32 message type, the encoders are published with Int16 message type, and we subscribe to the cmd_vel topic that uses the Twist message type. When wanting to add additional Publishers Subscribers, you must add an include statement for each different message type you plan on using. #include \"PheenoV2Basic.h\" The last include statement is required to help initialize the Arduino Teensy connection to the remainder of the Pheeno hardware. Global Variables Typically, variables defined within this section are considered global variables within the Arduino Teensy script. This is where we will define most of our variables relating to ROS. Create ROS Node instance ros::NodeHandle nh; Create Pheeno Instance PheenoV2Basic pheeno_robot = PheenoV2Basic(2); rosserial_arduino requires the instantiation of a ROS node that contains modules to advertise and subscribe our Publishers and Subscribers, respectively. In our case, the nh variable will serve as our ROS node. Creating an instance of PheenoV2Basic takes a variable 1 through 3 as options. You do not need to know what those other options are yet; however, we will discuss what those options mean in a different section. Create Messages for Publishers std_msgs::Float32 scan_center_msg; std_msgs::Float32 scan_back_msg; std_msgs::Float32 scan_right_msg; std_msgs::Float32 scan_left_msg; std_msgs::Float32 scan_cr_msg; std_msgs::Float32 scan_cl_msg; std_msgs::Int16 encoder_LL_msg; std_msgs::Int16 encoder_LR_msg; std_msgs::Int16 encoder_RL_msg; std_msgs::Int16 encoder_RR_msg; In our code, we create a message variables for the Publishers and Subscriber made later. The reason we use Float32 and Int16 is due to the hardware actually generating the readings with those types. Notice that we are using std_msgs:: version of Float32 and Int16. The ROS Publishers and Subscribers will only use variables that contain the ROS message wrapper, i.e. std_msgs::. Create Variables for Storing Motion Data int linear = 0; Forward and Backward motion. int angular = 0; Turning (Right and Left) motion. We will talk more about the use of these variables later, but, for now, we define the previous two variables. Create Publishers ros::Publisher pub_ir_center(\" scan_center\", &amp;scan_center_msg); ros::Publisher pub_ir_back(\" scan_back\", &amp;scan_back_msg); ros::Publisher pub_ir_right(\" scan_right\", &amp;scan_right_msg); ros::Publisher pub_ir_left(\" scan_left\", &amp;scan_left_msg); ros::Publisher pub_ir_cr(\" scan_cr\", &amp;scan_cr_msg); ros::Publisher pub_ir_cl(\" scan_cl\", &amp;scan_cl_msg); ros::Publisher pub_encoder_LL(\" encoder_LL\", &amp;encoder_LL_msg); ros::Publisher pub_encoder_LR(\" encoder_LR\", &amp;encoder_LR_msg); ros::Publisher pub_encoder_RL(\" encoder_RL\", &amp;encoder_RL_msg); ros::Publisher pub_encoder_RR(\" encoder_RR\", &amp;encoder_RR_msg); Here we define our Publishers. Each publisher takes in two arguments. The first is the ROS Topic you would like to publish, and the second is the ROS message variable associated with the Topic. Note the use of an &amp; ahead of the variable. This means that the second argument is actually the reference to the ROS message variable. Create Subscribers ros::Subscriber&lt;geometry_msgs::Twist&gt; sub_cmd_vel(\"cmd_vel\", callback); I skipped a couple lines, but will refer back to them in a second. Subscribers are defined slightly different from Publishers. As you can see, we need to specify within the type declaration that the recieved message will be a geometry_msgs::Twist. Just like in the Publisher, our first argument is the ROS message Topic; however, the second is a function! We refer to this as a callback function. Once the Publisher of a Topic publishes a message, the Subscriber will get the message and send it to the callback function for parsing (interpreting). The callback function used in this code is simply called callback. If you plan on adding more callback functions in the future, make sure to give them more specific names! It is not necessary to define the callback function before defining your Subscriber, but I do this for organizational purposes. Callback for cmd_vel Subscriber. The following callback recieves a command in terms of m s. This will have to be converted into a binary output between 0-255. void callback(const geometry_msgs::Twist &amp;msg) { if (msg.linear.x &gt; 0 || msg.linear.x &lt; 0) { linear = 2550 * msg.linear.x; angular = 0; } else if (msg.linear.x == 0) { linear = 0; } if (msg.angular.z &gt; 0 || msg.angular.z &lt; 0) { linear = 0; angular = 2550 * msg.angular.z; } else if (msg.angular.z == 0) { angular = 0; } } callback takes with it one argument: the Twist message’s reference. As seen above, dot operators can access a msg variables data. The specific path towards the data is dependent on the ROS message type. For geometry_msgs::Twist, we can access the information as such. msg.linear.x msg.linear.y msg.linear.z msg.angular.x msg.angular.y msg.angular.z For this differential drive robot, we will only be using linear.x and angular.z. We will use he former messages information to provide linear forward and backward motion while the later gives angular rotation about the z-axis of the robot. Why do we use only two? Looking at the top of the Pheeno, imagine 3 vectors emanating from the pheeno: one from the center pointing forward, one from the center pointing out of the left side, and one from the center point vertically upwards. The distinction of linear means movement is in the direction of the vector. linear.y is not possible due to the fact that the robot is non-holonomic. The wheels cannot move the Pheeno to the left or right without turning! Unless the Pheeno has become equipped with a tiny jetpack, it won’t be able to move upwards either, so linear.z isn’t an option either. Angular works differently. Instead of forward and backward motion from the vector, angular motion is rotation about the vector. Take out a pencil, if you have one. Put the eraser on a horizontal surface and have the tip pointing vertically. Now rotate in place. The eraser shouldn’t move and the pencil should stay in place. This is what we mean when we say rotating about an axis or vector. In the Pheeno’s case, the only axis that makes sense to rotate about is the z-axis. That is why we only need angular.z. Going back to the code, the callback function assigns the subscribed value from the cmd_vel topic message to the linear and angular values. Setup Function void setup() { Setup Pheeno robot pheeno_robot.SetupBasic(); Initialize ROS Node nh.initNode(); Start Advertising nh.advertise(pub_ir_center); nh.advertise(pub_ir_back); nh.advertise(pub_ir_right); nh.advertise(pub_ir_left); nh.advertise(pub_ir_cr); nh.advertise(pub_ir_cl); nh.advertise(pub_encoder_LL); nh.advertise(pub_encoder_LR); nh.advertise(pub_encoder_RL); nh.advertise(pub_encoder_RR); Start Subscribing nh.subscribe(sub_cmd_vel); } The setup() function of Arduino code is initialized every time the Arduino is powered on or reset. Therefore, every time the Arduino is reset (or powered on) the Pheeno must run the SetupBasic() and the initNode() methods. The first initializes the Pheeno for use, while the second method initializes the ROS node we wish to use. As a note, BOTH these statements must be present when attempting to write your own code for the Pheeno. Next, the node nh must advertise and subscribe the Publishers and Subscribers, respectively. Loop Function void loop() { Refresh Sensor Readings pheeno_robot.readIR(); pheeno_robot.readEncoders(); The loop() function is repeated continuously until reset or a power cycle instance. Therefore, We will focus on this section because it is what allows interaction with ROS. At the beginning of every loop, we read both of our IR sensors and encoders. Assign sensor values to Msg variable scan_center_msg.data = pheeno_robot.CDistance; scan_back_msg.data = pheeno_robot.BDistance; scan_right_msg.data = pheeno_robot.RDistance; scan_left_msg.data = pheeno_robot.LDistance; scan_cr_msg.data = pheeno_robot.RFDistance; scan_cl_msg.data = pheeno_robot.LFDistance; encoder_LL_msg.data = pheeno_robot.encoderCountLL; encoder_LR_msg.data = pheeno_robot.encoderCountLR; encoder_RL_msg.data = pheeno_robot.encoderCountRL; encoder_RR_msg.data = pheeno_robot.encoderCountRR; As I explained earlier for Twist messages, ROS data types are wrappers for the information that is sent. In the case of std_msgs::Float32, the variable is not Float32, but the variable has a parameter named data which is Float32. The values that come from the IR Sensor and Encoders are assigned to variable_name.data instead of just variable_name. Publish the Topics pub_ir_center.publish(&amp;scan_center_msg); pub_ir_back.publish(&amp;scan_back_msg); pub_ir_right.publish(&amp;scan_right_msg); pub_ir_left.publish(&amp;scan_left_msg); pub_ir_cr.publish(&amp;scan_cr_msg); pub_ir_cl.publish(&amp;scan_cl_msg); pub_encoder_LL.publish(&amp;encoder_LL_msg); pub_encoder_LR.publish(&amp;encoder_LR_msg); pub_encoder_RL.publish(&amp;encoder_RL_msg); pub_encoder_RR.publish(&amp;encoder_RR_msg); After assigning the proper values from the hardware to the ROS Message variables, it is now time to publish those message in their respective ROS Topics. We use the publish() method for each Publisher to publish the messages we want. Remember, the argument must be the reference to the message variable. if (linear != 0) { if (linear &gt; 0) { PheenoMoveForward(linear); } else { PheenoMoveReverse(linear); } } else if (angular != 0) { if (angular &gt; 0) { PheenoTurnLeft(angular); } else { PheenoTurnRight(angular); } } else { pheeno_robot.brakeAll(); } After publishing, linear and angular variables are analyzed and movement assigned to the proper functions to move the Pheeno. The Pheeno will stop if either variable is set to zero. nh.spinOnce(); delay(100); Required because the Teensy sends messages too fast. } The spinOnce() method gives control of the program to ROS for only one cycle, then lets go. ROS will only process callbacks if you use spinOnce(). Therefore, we must use it in our code if we want to receive information about the cmd_vel topic. This is how rosserial_arduino (and ROS C++ code) handles Subscribers within nodes. The delay() function following spinOnce() method serves to force the system to slow down slightly. If not present, errors about missing communications will occur when attempting to connect the Arduino Teensy to the Pheeno’s Raspberry Pi Once you have a good grasp of the information provided, upload the code to the Arduino Teensy!"
					}

					
				
			
		
			
				
					,
					

					"ros-pheeno-ros-installation-guide": {
						"id": "ros-pheeno-ros-installation-guide",
						"title": "ROS Installation for Pheeno",
						"category": "",
						"url": " /ROS/pheeno-ros-installation-guide/",
						"content": "Introduction Currently, Pheeno is only supported by ROS Indigo; However, ROS Kinetic support is next. The following guide will show you how to install ROS and other necessary packages for the Raspberry Pi on the Pheeno. Installing ROS Indigo Setup ROS Repositories First, we would like to pull packages from the official ROS repository, so we must add ROS to our list of Ubuntu repositories. sudo sh -c 'echo \"deb http: packages.ros.org ros ubuntu jessie main\" &gt; etc apt sources.list.d ros-latest.list' wget https: raw.githubusercontent.com ros rosdistro master ros.key -O - | sudo apt-key add - From now on, updating and upgrading commands will result in listings and updates for ROS packages. We will do an initial update of the system with the newly added ROS source. sudo apt-get update sudo apt-get upgrade Install Bootstrap Dependencies ROS requires some necessary Python packages. The first command will download Python specific packages that are good for development. As an aside, the Python packages we will be downloading are fantastic and should be learned irrespective of using ROS. Once those packages are installed, we will use pip, a Python package manager, to install ROS specific Python packages. sudo apt-get install python-pip python-setuptools python-yaml python-distribute python-docutils python-dateutil python-six sudo pip install rosdep rosinstall_generator wstool rosinstall Initialize rosdep One of the previous packages installed called rosdep is a ROS package installer capable of fulfilling dependencies for many packages. Once installed from pip, we need to initialize it as such. sudo rosdep init rosdep update Create a catkin Workspace To begin the ROS installation, we need to create a workspace to build everything. In the main directory, we will create ros_catkin_ws to begin building ROS onto the Raspberry Pi. mkdir ~ ros_catkin_ws cd ~ ros_catkin_ws To begin building, we will create a ROS installation file containing all the files and dependencies needed. The Raspberry Pi is underpowered and won’t really run the full desktop suite effectively. Therefore, we will just install the ros_comm package, which contains ROS, build, and basic communication libraries. wstool, a command line tool for maintaining workspaces, will then initialize a workspace around our rosinstall file. rosinstall_generator ros_comm --rosdistro indigo --deps --wet-only --exclude roslisp --tar &gt; indigo-ros_comm-wet.rosinstall wstool init src indigo-ros_comm-wet.rosinstall Installing Unavailable Dependencies mkdir ~ ros_catkin_ws external_src sudo apt-get install checkinstall cmake sudo sh -c 'echo \"deb-src http: mirrordirector.raspbian.org raspbian testing main contrib non-free rpi\" &gt;&gt; etc apt sources.list' sudo apt-get update cd ~ ros_catkin_ws external_src sudo apt-get build-dep console-bridge apt-get source -b console-bridge sudo dpkg -i libconsole-bridge0.2*.deb libconsole-bridge-dev_*.deb cd ~ ros_catkin_ws external_src apt-get source -b lz4 sudo dpkg -i liblz4-\\*.deb Resolving Dependencies with rosdep cd ~ ros_catkin_ws rosdep install --from-paths src --ignore-src --rosdistro indigo -y -r --os=debian:jessie Building the catkin Workspace sudo . src catkin bin catkin_make_isolated --install -DCMAKE_BUILD_TYPE=Release --install-space opt ros indigo -j2 source opt ros indigo setup.bash echo \"source opt ros indigo setup.bash\" &gt;&gt; ~ .bashrc Thats it! Installing Other Necessary Packages The previous section explained the base installation of ROS Indigo on the Raspberry Pi. To use other packages is a bit tricky, but the following guide provides a convenient way of installing the packages on the Pheeno. First, change back to the main directory. cd From here, we will make a directory called catkin_ws with a child directory called src. mkdir -p ~ catkin_ws src Finally, we change directory to the src dictory and initialize the workspace. cd ~ catkin_ws src catkin_init_workspace This new catkin workspace will allow us to install other ROS packages. Getting the rosserial Package rosserial is required for communication between the Raspberry Pi and the Teensy board. Our project requires three packages within the repository: rosserial_client, rosserial_arduino, and rosserial_python. To attain these files, we need to use git clone within the src folder. cd ~ catkin_ws src git clone -b indigo-devel https: github.com ros_drivers rosserial.git The -b flag indicates that we would like to use the ROS Indigo specific branch of their respository. The default branch for the project is currently only for ROS Jade. Getting the common_msgs Package The base installation of ROS only comes with standard messages (std_msgs). To get other message types such as Twist and action messages, we need to install the common_msgs package. Again, we will use git clone. cd ~ catkin_ws src git clone -b indigo-devel https: github.com ros common_msgs.git We again pull from the ROS Indigo specific branch of the repository. Getting the actionlib Package This is an optional download entirely dependent on your use case. This is typically a default package for ROS; however, the ros_comm installation from before does not contain it. To download, we just need to clone the indigo-devel branch from the official ROS GitHub repository. cd ~ catkin_ws src git clone -b indigo-devel https: github.com ros actionlib.git Getting the cv_bridge Package The pacakges within the vision_opencv repository contain files for interfacing ROS with OpenCV. In ROS, the image message type is not compatible with any OpenCV functions. Therefore, the cv_bridge bridge package has some nice functions for converting image messages to OpenCV Mat variables and vica versa. To install, we will clone from the ros-perception GitHub repository from their ROS indigo development branch. cd ~ catkin_ws src git clone -b indigo-devel https: github.com ros-perception vision_opencv.git Getting the pheeno_ros Package To get our ROS package for the Pheeno, we just need to clone it from our organization repository. cd ~ catkin_ws src git clone https: github.com ACSLaboratory pheeno_ros.git Installing the Packages Once the packages download, we can then install the packages using catkin_make. Remember to be within the catkin_ws directory and not the src directory when running the following commands. cd ~ catkin_ws catkin_make -j2 catkin_make install -j2 Installing PlatformIO PlatformIO is not a necessary package, but it is definitely helpful when deploying multiple Pheenos. Teensy requires a small GUI to upload files into the microcontroller. Using PlatformIO circumvents this by allowing uploaded code using the command line, which is great if you want to ssh into the Pheeno. If you are ok with using a GUI each time you want to upload code to the Teensy, then you are more than welcome to skip this section. For those who do want the package, we just need to do a quick pip installation. cd sudo pip install -U platformio Next, create a directory that will act as a project folder. For example, we used the inventive name of Teensy as our project folder and then went into the directory. mkdir Teensy cd Teensy From here, we will use PlatformIO to initialize the folder for work. platformio init --board teensy31 The --board teensy31 argument provides the workspace the knowledege we will be working with a Teensy 3.2 board. The command above creates 2 empty directories and a project file. Place all the Arduino Teensy library files within the lib directory and the actually file you wish to upload within the src directory. Now within the Teensy directory, run the following commands. cd ~ Teensy platformio run platformio run --target upload Both PlatformIO commands will download some pertinent Teensy microcontroller files and then begin the upload process. The above commands only need to be run once. Every subsequent upload to the Teensy only requires the second command to be run (it is also much faster than the first run). platformio run --target upload"
					}

					
				
			
		
			
				
					,
					

					"ros-pheeno-ros-server-guide": {
						"id": "ros-pheeno-ros-server-guide",
						"title": "pheeno_ros_server ROS Package Guide",
						"category": "",
						"url": " /ROS/pheeno-ros-server-guide/",
						"content": "Coming soon!"
					}

					
				
			
		
			
				
					,
					

					"ros-pheeno-ros-sim-guide": {
						"id": "ros-pheeno-ros-sim-guide",
						"title": "pheeno_ros_sim ROS Package Guide",
						"category": "",
						"url": " /ROS/pheeno-ros-sim-guide/",
						"content": "Coming soon!"
					}

					
				
			
		
			
				
					,
					

					"controls-pheeno-controller-guide": {
						"id": "controls-pheeno-controller-guide",
						"title": "Controller for Pheeno Navigation",
						"category": "",
						"url": " /controls/pheeno-controller-guide/",
						"content": "Introduction This document describes the controller design for the motors that drive Pheeno as well as the higher level controller that navigates the robot from one location to another. To create these controllers accurate models of the motors and robot are needed. The choice of models and fitting will be discussed in the Modeling the Motors and Modeling the Robot sections. The controller design sections will address which sensors are used to calculate the desired feedback but the details are discussed in the observer design document and thus, will not be talked about here. The simplest possible models are used to design controllers for Pheeno. To understand this choice, refer to the passage from George Box’s 1978 paper, Now it would be very remarkable if any system existing in the real world could be exactly represented by any simple model. However, cunningly chosen parsimonious models often do provide remarkably useful approximations. For example, the law $PV = RT$ relating pressure $P$, volume $V$ and temperature $T$ of an “ideal” gas via a constant R is not exactly true for any real gas, but it frequently provides a useful approximation and furthermore its structure is informative since it springs from a physical view of the behavior of gas molecules. For such a model there is no need to ask the question “Is the model true?”. If “truth” is to be the “whole truth” the answer must be “No”. The only question of interest is “Is the model illuminating and useful?” The better known section header of this passage is, All models are wrong but some are useful. There is a need for the model to capture the properties of the system that are useful without overparamertizing or overelaborating the model. Using more intricate models than are needed makes the controller design more complicated and, more importantly, over fits the data used to parameterize the system which can cause this model to describe a certain data set more than the system it is meant to represent. With the use of feedback control, even simple models that do not describe the system completely can be controlled in desirable fashion. Modeling the Motors The first and arguably most important step towards controlling the system is designing a fast controller for the motors. To do this an accurate model of the motors must be created. Typically, this would be done by parameterizing the standard second order transfer function for a direct current (DC) motor, where $K_T$ is the gain relating the armature current to armature torque, $K_B$ is the gain relating the rotational velocity of the rotor to the back EMF in the armature circuit, $J$ is the inertial of the rotor, $b$ is the viscous friction acting on the rotor, $L$ is the inductance in the armature circuit, and $R$ is the resistance in the armature circuit. However, for micro-metal gear motors, like the ones used on Pheeno, $L « R$. This allows for the second order system to be approximated by a first order system by setting $L=0$ yielding, where, To fit these parameters, the motors will be black box modeled using MATLAB’s system identification toolbox \\cite{ljung2017system}. Two motors attached to Pheeno were given step voltages and sinusoidal voltages of frequencies between $0.1$ and $50$ Hz. The max sinusoidal frequency was chosen following the Nyquist sampling criterion which states a signal may only be recreated if it is sampled twice as fast as its highest frequency component. The rotor rotational velocities were measured with its encoders at a rate of $100$ Hz. The input and output time plots are shown in Figure 1. Figure 1: The voltage input (top) and rotor velocity output (bottom) signals for a DC motor. From these plots, it is apparent there is a large magnitude drop off as the frequency of the input signal increases. This is expected in a natural system like the DC motor. This data is given to the system identification toolbox to fit a first and second order continuous model of the motor. As expected, the first and second order transfer functions yield equal “goodness of fit” to the data $\\sim 80\\%$. This fit is a little low but acceptable as a linear model is unable to represent nonlinear friction effects on the motor rotor. The first and second order system both have a pole at $\\sim 36$ rad s with the second order system also having a pole at $\\sim 60,000$ rad s. From this fitting it is obvious the dynamics of the motor are dominated by the single pole. The location of the pole fit also makes sense as the magnitude of the sinusoidal response begins to decay around $30$ rad s as is expected with roll off caused by a pole. This leaves the first order approximation of the system. The model compared to a set of validation data can be seen in Figure 2. (a) (b) Figure 2: The first order DC motor model (red) compared to validation data (black) Controlling the Motors Continuous Consideration From this plant it is possible to design a controller so that the motor responds in a desired way. For this application it is desirable to make the motors follow step commands (and rejects step disturbances) as fast as possible with no overshoot. From the internal model principle, a proportional integral (PI) controller is enough to satisfy these requirements. Figure 3: A block diagram representation of a standard negative feedback loop. This formulation leads to a standard feedback problem that must be solved. Figure 3 shows a block diagram of standard negative feedback loop with the symbols that will be used here. The plant, $P(s)=\\frac{2.9876}{s+36.07}$, was found previously, a PI controller, $K=g\\frac{s+a}{s}$, needs to be designed, and a pre-filter, $W=\\frac{a}{s+a}$, needs to be incorporated to reduce the overshoot caused by the zero of the controller. Here, the sensor dynamics, $H$, are assumed to be ideal. Typically, in a classroom setting, a pole placement method would be employed to match the nominal closed loop system to some desired closed loop system. In this case, a slightly different method will be employed. The plant here is a nominal representation of the system. This means there are higher order dynamics present in the system that are not modeled so the gain chosen cannot be very high and the dominant pole modeled here can be slightly or significantly off. First, $a$ will be chosen with these real world constraints in mind, then $g$ will be chosen such that there is no overshoot and the motors spin up as fast as possible. First, notice the pre-filter is a stable low pass filter (presuming $a &gt; 0$). This means it will create a natural delay on the reference signal depending on how small $a$ is chosen. Thus $a$ should be chosen to be large such that this delay does not significantly slow down the motor’s response to low frequency reference commands and does not restrict the magnitude of desired higher frequency signals. However, it should be chosen low enough that the integral term of the controller does not become too large and exacerbate the integral windup problem caused by motor saturation (which will be addressed later). Secondly, the proposed open loop system’s ($KP$) root locus will result in two different looking root locus depending on how $a$ is chosen. Figure 4 shows an example of both root locus. Note choosing $a$ larger than the dominant pole of the modeled motor has two critical damping points. The left critical damping point requires a much larger gain and thus will not be considered. The right critical point will shift left as $a$ is chosen closer to the pole of $P$ making the closed loop system’s response faster. To make the system as fast as possible, choose $a = 36.07$ so it cancels the pole of the motor. Typically, this is not a good idea because of modeling errors that cause this cancellation to not be true in reality. However, because it is a very stable pole, this choice does not have such severe consequences as model error will result in one of the two root locus represented in Figure 4. (a) (b) Figure 4: The root locus of Pheeno’s motors where the zero of the controller is chosen larger (top) and smaller (bottom) than the modeled pole of the motor. The gain, $g$, is chosen such that the rise time of the system is $&lt;0.5$ s. Figure 5 shows a simulated step response of this controller and modeled plant which behaves as expected. Figure 5: The simulated step response of the designed continuous motor control loop. Dealing with Integral Windup Integral windup is a problem that occurs in controllers containing integral terms when a large change in the reference command occurs. For example, if Pheeno is suddenly commanded to go from rest to full speed there will be a large error initially that will get smaller as Pheeno begins to reach its top speed. However, during this time the integral term of the controller will be compounding this error and cause an overshoot until enough error has occurred in the opposite direction to offset it. This gets worse when saturation of actuators are considered. In this case, a naive controller can require an output larger than what can be produced by the actuator. This causes integration error to continue to compile without knowledge that the error it is trying to rectify is beyond the capabilities of the system. There are several ways to address this issue. In Pheeno, this issue is addressed by adding a secondary feedback loop that limits the integral term when motor saturation has occurred. Figure 6 shows this feedback loop in block diagram form. This feedback loop only kicks in if the controller’s desired output is higher or lower than the actuator can output. When saturation occurs, the feedback loop keeps the integral term from compounding when the error cannot be reduced. Typically the tracking gain, $K_t$, is chosen to be equal to the integral gain, $K_i$, but higher values can cause better performance \\cite{bohn1994simulink}. Figure 6: Comparison of model to motor output for several reference commands. Discrete Time Adaptation It would be naive to just throw this controller onto the robot and assume the motors will respond as they were designed to. If the controller were designed in the continuous domain without accounting for the delays created by the sampling of the microcontroller, it is very likely the control would be unstable at worse or not exhibit the designed properties at best. The Teensy microcontroller can easily perform control loops at $100$ Hz. Thus a sampling time of $0.01$ is chosen to design the motor control around. First, the plant should be transformed from the continuous domain to the discrete domain. There are many options to transform a continuous plant represented in the s-domain to the discrete time z-domain. For the plant, a zero-order hold (ZOH) conversion is chosen as that best represents the type of hold circuit that will be used in sampling the motor. The controller designed in the continuous case is transformed using the bilinear transformation to better approximate the continuous behavior of the controller in the discrete space. This control case is ideal as the sampling time is very fast compared to the desired rise time. Thus, the continuous system is very close to the discrete system. Figure 7 shows the step response of the discrete designed system with the continuous designed system. However, in general this will not be the case and the continuous system would need to be augmented with an additional gain to get the desired response characteristics or redesigned entirely. To validate this control, several known commands are given to two different motors on two different robots. The model’s prediction is compared to the motor outputs in Figure 8. For large jumps in the reference command, like the last two step commands, the integral windup overshoot is apparent but not overwhelming. This could be remedied with a less aggressive controller or putting a more restrictive low pass pre-filter on the reference commands. This would slow down the response considerably which is undesirable. Figure 7: Comparison of simulated step response of the designed continuous and discrete motor control loop. The (blue) line shows the discrete time step response and the (red) line shows the continuous step response. Figure 8: Comparison of model to motor output for several reference commands. Modeling the Robot Pheeno is by default a differential drive robot. This means each wheel can be controlled independently to produce desired motion. However, this makes the robot a coupled system resulting in a multi input multi output system which can be tricky to control properly. To simplify this, a decoupled kinematic model is used to represent Pheeno’s motion and control its position and orientation in a global reference frame. This can be done since Pheeno is so light and its motion is dominated by the motor torques. An extremely in depth analysis about when this assumption can be used is done by \\citet{anvari2013non} in his master’s thesis. Figure 9: Representation of Pheeno in a Cartesian coordinate frame. Consider Pheeno in an inertial reference frame ${X_o, Y_o}$ as shown in Figure 9. Pheeno’s basic motion model is, what is commonly referred to as, the unicycle model. :label: UnicycleWV This model transforms the robot’s linear velocity, $v$ , and rotational velocity, $w$ , in Pheeno’s reference frame to velocity states in the inertial frame. However, the robot’s linear and rotational velocity cannot be controlled directly so another transformation is needed linking the rotational velocity of the wheels, $v_R$ and $v_L$ , to $v$ and $w$ . This relation is derived more thoroughly in \\citet{malu2014kinematics}. :label: UnicycleConversion Here, $r$ is the wheel radius and $L$ is the axle length of the differential drive robot. Combining \\autoref{eq:UnicycleWV} and \\autoref{eq:UnicycleConversion}, yields the final relation between the wheel speeds of the robot and the velocity states in the inertial reference frame. :label: UnicycleRL However, it is much more intuitive to use the unicycle model (\\autoref{eq:UnicycleWV}) thus control will be done to create reference linear velocities, $v$ , and rotational velocities, $w$ , for the robot to follow. These will then be transformed to motor velocity commands using \\autoref{eq:UnicycleConversion}. In discrete time, this unicycle model takes the form, :label: DUnicycleWV This unicycle model has slight changes to the orientation model that can be found in a paper by \\citet{kiriy2002three}. Using this model over the usual one showed vast improvements in dead reckoning navigation for Pheeno. Controlling the Robot’s Motion The approach to using the unicycle model to navigate Pheeno from an initial position to a goal position described here is using a layered architecture. This means using a high level planner to design way points for the robot to pass through, which are then translated to linear and rotational velocities of the robot, which are finally put through the fast PI controller of the motors. This section focuses on the middle component which decides the set points for the linear and rotational velocities. Assume the high level planner has given an initial desired position $\\vec{u} = [u_x \\hspace{2mm} u_y \\hspace{2mm} u_\\theta]^T$ . From a Lyapunov stability analysis in \\cite{malu2014kinematics} the controllers which produce stable global position tracking are, where $K_p &gt; 0$ is a gain associated with radial distance error from the goal location, $\\rho = \\sqrt{(u_x - x)^2 + (u_y - y)^2}$ , and $K_\\alpha &gt; 0$ is a gain associated with the robot’s heading error from the goal orientation, $\\alpha = atan2(\\frac{u_y - y}{u_x - x})$ . It should be noted the heading error, $\\alpha$ , is bounded $[-\\pi, \\pi]$ which limits how large $w$ can get. However, the radial distance error, $\\rho$ , is unbounded. Thus, it is typical in application to either know the bounds of $\\rho$ when designing $K_p$ as a constant or choosing $K_p$ to be of the form, which limits the maximum linear velocity of the robot to a designed $v_0$ . When designing for any application, the gains should be chosen carefully to avoid wheel slip caused by high accelerations. The controllers should also operate slower than the rise time of the motor controller ($\\sim 0.1$ s) so the motors have a chance to produce the desired linear and rotational velocities demanded by the higher order controller."
					}

					
				
			
		
			
				
					,
					

					"controls-pheeno-observer-guide": {
						"id": "controls-pheeno-observer-guide",
						"title": "Using Pheeno's for Reliable Feedback",
						"category": "",
						"url": " /controls/pheeno-observer-guide/",
						"content": "This document is meant to help new robotics users and specifically users of the Pheeno robotic platform get used to onboard sensing typically used as feedback in control theory. Typically when learning the theory behind controllers the feedback term is assumed to be perfect and known. In reality, these feedbacks are based on sensor measurements that must be calibrated properly with limitations that should be known. There are many different types of sensors with large ranges of precision and cost. Here, the focus will be put on the sensors onboard the Pheeno platform and fusing their measurements to produce reliable feedback. Getting to Know the Onboard Sensors will provide a high level introduction to the sensors on board the Pheeno robotic platform, their strengths and weaknesses, and how they should be used. The Calibration section will go into how and why to calibrate sensors on board the robot. The Sensor Fusion for State Feedback section will introduce different methods to combine sensor measurements into reliable, robust position and orientation estimates for the robot. It will also briefly go into the pros and cons of each fusion. Getting to Know the Onboard Sensors Pheeno is equipped with a MiniIMU-9 v5 made by Pololu. This little board contains a 3-axis accelerometer, 3-axis gyroscope, and 3-axis magnetometer. Figure 1 shows the ideal reference frame of the MiniIMU-9 v5 aligned with Pheeno’s reference frame. Pheeno is also equipped with 6 infrared (IR) distance sensors, a quadrature encoder on each motor, and an RGB camera. Each of these sensors alone are very powerful, however, they each have critical weaknesses which will be explored below. Together, with the help of a little mathematics, these sensors make up for each other’s weakness and allow Pheeno to figure out where it is in space and what its surroundings are like. Figure 1: The reference frame of Pheeno. Ideally, this should be the same reference frame as the inertial measurement unit. One thing that will not be covered in this document is converting raw data voltages provided by the MinIMU-9 v5 or any of the sensors on the robot. For reference, sensors typically output analog or digital voltages which must be converted to digital signals that may then be transformed to standard units by a micro processor. Other, more complex sensors, have micro chips on board that use communication protocols like Inter Integrated Circuit Communications, $I^2 C$, and Serial Peripheral interface (SPI). A typical inertial measuring unit (IMU) like the MiniIMU-9 v5 will not output raw data in any units that are useful to the operator. IMUs like this typically have different operating ranges that can be set by the user. For whatever range is chosen by the user, a conversion factor is typically given in the datasheet associated with the IMU. It is important to note however, all sensors on a robot are quantized at some resolution (meaning whatever continuous source they measure will be represented at discrete increments). Typically there is a trade off between the resolution of measurements and the range of values that can be measured. For example, the standard setting for the gyroscope on Pheeno is set to measure an angular rotation rate range of $\\pm 245 ^\\circ s$. This allows for a measurement resolution of $0.00875^\\circ s$. This is fine for determining rotations on a small robotic platform like Pheeno but this concept should not be ignored. The resolution and range of any sensor on board should be chosen as appropriate to the application. Accelerometer An accelerometer measures its linear acceleration along several principle directions. In Pheeno’s case the MiniIMU-9 v5 has a 3-axis accelerometer allowing the user to know how the robot’s linear acceleration in all three possible dimensions. From this sensor alone the user can infer the direction the robot is accelerating as well as its pitch and roll angle (if you are unfamiliar with roll and pitch angles, refer to Figure 12, they will be further explained later). If Pheeno drives off a cliff, it will be very apparent from the accelerometer’s sensor measurements that it is tumbling to its doom. To explain what an accelerometer should be used for, raw accelerometer data from a resting and rotating Pheeno will be analyzed. First, Pheeno was placed onto a table top and 60 seconds of accelerometer data was recored at a rate of 100 Hz (every 10 ms). Figure 2 shows the raw time series data of the the acceleration felt along each axis of the accelerometer. This data shows the readings are noisy but very stable. The accelerometer is currently just measuring gravity which should be only in the z-direction. However, from this plot we can see there are slight measurements in the x and y direction as well. This is due to slight misalignment between the IMU board orientation and Pheeno’s resting orientation caused during manufacturing of the robot. A misalignment similar to this should be present in every robot. From this data, it is possible to calibrate the accelerometer and determine how tilted the board is relative to the robot, thus aligning their reference frames. Figure 3 shows the acceleration along the Y-Direction of the accelerometer after the time averaged bias has been subtracted. From this we can see most of the noise in the raw sensor measurements (black line) is around $\\pm 1 cm s$. If the sensor is moved around quickly, the accelerations of the motion will be measured and the vibrations during the motion will amplify the noise. It should be noted how the $100$ sample running mean of the signal (red line) provides a much more stable signal. This shows the noise content of the signal is at a high frequency and a low pass filter can be used to get reliable measurements from the accelerometer. However, a low pass filter will not track quick acceleration changes well by its design. This will be addressed later. Figure 4 shows the velocity approximated from the accelerometer if the accelerometer measurements are integrated. Over small time intervals this works reasonably well but over long time periods integration error overwhelms the approximation. Recall, this is from an accelerometer at rest on a table. During the $60$ second interval pictured, the at rest accelerometer yields non zero velocities. Note this happens even when the signal is averaged and the noise is not as severe. Figure 5 shows the position approximated from integrating the accelerometer measurements twice. As expected this leads to compounded integration error which causes this position approximation to be $7.5$ cm from its original location in $60$ seconds. If left to rest for a longer period of time, the accelerometer’s estimation of position will only get worse. From these results, an accelerometer should really only be used to determine the angle of orientation of the robot (pitch and roll), the acceleration of the robots motion, and sometimes the velocity of the robot over short time periods. These become tricky when the robot is actually being driven around since acceleration from the motion of the robot and interaction between the robot and its environment is measured by the accelerometer. If the robot is in a terrain where the ground changes the orientation of the robot drastically this challenge becomes even more difficult but not impossible. Later the accelerometer’s readings will be combined with other on-board sensors to give an accurate measurement of the robot’s orientation and linear acceleration. An accelerometer should almost never (really never) be used to approximate the robot’s position through integration, especially over longer time scales. Integration error adds up very quickly and throws off a robot’s localization significantly. Figure 2: The time evolution of raw accelerometer data along each axis of the magnetometer measured when Pheeno is resting on a table. The blue line is along the x-direction of the IMU, the red line is along the y-direction of the IMU, and the black line is along the z-direction of the IMU. Figure 3: The time evolution of raw accelerometer data (black) and averaged accelerometer data (red) along the y-direction of the IMU after the time averaged bias is subtracted. The average line is a running $100$ sample average. Figure 4: The time evolution of the approximation of velocity after integrating accelerometer measurements from Figure 3. The blue line is from integrating the raw accelerometer data, the red line is from integrating the running $100$ sample averaged accelerometer data. Figure 5: The time evolution of the approximation of position after integrating accelerometer measurements from Figure 3 twice. The blue line is from integrating the raw accelerometer data, the red line is from integrating the running 100 sample averaged accelerometer data. Gyroscope Gyroscopes measure the rotational velocity about several principle axes. In Pheeno’s case, the MiniIMU-9 v5 has a 3-axis gyroscope allowing the user to know how fast the robot is rotating about each axis. This sensor is typically used in parallel with the magnetometer and accelerometer to determine the angular orientation of the robot at all times. Unlike the accelerometer and magnetometer which typically have very accurate but noisy signals that cannot detect fast motions, gyroscopes are great at capturing fast rotations without being affected by the accelerations, but their orientation estimates will drift over time due to integration error. To better understand a gyroscope’s output and limitations Pheeno was manually rotated $90$ degrees [$\\sim 1.57$ radians] back and forth about its z-axis for $60$ seconds. The raw data is shown in Figure 6(a). Due to the misalignment of the MiniIMU-9 v5 board with the robot’s reference frame, there is noticeable rotation about the z-axis (yaw) and y-axis (roll) and x-axis (pitch). This can be corrected in calibration which will be discussed in the Gyro Calibration section. The corrected data are shown in Figure 6(b). This data shows that the gyroscope is very good at capturing consistent angular rate data at high frequencies with a relatively small amount of noise. Figure 7(a) shows the data from Figure 6(a) integrated once to determine the Pheeno’s orientation. Again, this data is uncalibrated and the errors from the misalignment and offset add up quickly. After calibration this runaway integration decreases as shown in Figure 7(b). The yaw orientation estimate is fairly consistent showing approximately $90$ degrees of rotation back and forth at two different rates. Due to the nature of the rotation (manually turning the robot back and forth and eyeballing a $90 ^{\\circ}$ rotation) there is slight deviation in the periods of the rotations as well as the magnitudes. The calibration here is not perfect as some of the rotation is captured in the roll estimate but this is small and with more exact and thorough calibration can be suppressed further. The weakness of gyroscope measurements is commonly referred to as drift, where the integration error causes the estimate to “drift” in one direction. Figure 7(b) shows this as the yaw estimate is slowly becoming more and more negative. Gyroscopes are great at estimating rotations over small time scales but suffer if this estimate is done for long periods of time. While frustrating, it is important to note this is the opposite of the accelerometer measurements which are not reliable over short time spans but very reliable over long ones because their orientation estimate does not rely on integration and thus will not drift. However, accelerometers are only able to recover two angles of orientation, which have been chosen to be pitch (rotation about the x-axis) and roll (rotation about the y-axis). In order to determine the robots yaw angle (rotation about the z-axis) for long time spans, the robot requires an additional sensor, the magnetometer. (a) (b) Figure 6: The time evolution of the (a) uncalibrated and (b) calibrated rotational velocity measurements about each axis measured by the gyroscope on board Pheeno. The robot was rotated $90$ degrees back and forth over a $60$ second period. (a) (b) Figure 7: The time evolution of Pheeno’s estimation of orientation from integration of (a) uncalibrated and (b) calibrated gyroscopic rate measurements in Figure 6(a) and Figure 6(b). The robot was rotated $90$ degrees back and forth over a $60$ second period. Magnetometer The magnetometer is very similar to an accelerometer. However, in stead of measuring a gravity vector it measures the direction of the magnetic field surrounding it. The magnetometer on the MiniIMU-9 v5 represents the magnetic field vector along the same axis as the accelerometer. Its readings do not drift (given there are no magnetic anomalies) but are noisy like the accelerometer. Typically the magnetic field being read is dominated by the earth’s magnetic field. This field can easily be influenced by other magnetic sources like wires carrying large currents in buildings, large motors onboard the robot, and large metal beams in buildings. Luckily Pheeno is a small robot that uses low current micro metal gear motors that do not produce large enough magnetic fields to really influence the magnetometer readings. In larger robots with bigger motors, the magnetometer’s proximity to the motors should be accounted for. Since Pheeno is typically used indoors, it is important for the user to determine if the room the robot is being used in has a consistent magnetic field. If the field changes too drastically in some areas those areas must be avoided or the magnetometer cannot be used reliably. Assuming the area the robot is in has a consistent magnetic field, when the robot is rotated the measured magnetic field vector should point to the surface of a sphere centered at the origin with radius equal the strength of the present magnetic field. However, without calibration the readings from a rotating robot will look like Figure 13(a). This plot is 2D planar slices of the 3D ellipsoid showing the resulting measurements are not a sphere centered at the origin. Typically the offset of this ellipsoid from the origin is referred to as hard iron error and the directional scaling in each direction is called soft iron error. It is crucial the magnetometer is calibrated properly to correct both these errors. If the magnetometer is not calibrated correctly, Pheeno will be unable to reliably determine its yaw angle and thus heading angle. This will be further discussed in the Magnetometer Calibration section. Motor Encoders Motor encoders are used to count the number of shaft rotations that have occurred. Figure 8 is a cartoon of a simple optical encoder. The wheel that is attached to the shaft blocks the light from hitting the sensor at set increments which creates a signal that is able to be measured by a micro controller. This is the foundation of all encoders. An emitter’s signal (the light source in this case) is interrupted by a shaft attachment creating known patterns (e.g. 12 per rotation, a known pattern at a set angle, etc). However, there are many variations of encoders which use different emitters (e.g. magnetic, optical, electrical contact, resistance, etc.), have different number of sensors, and should be used in different scenarios. Encoders typically fall into two classes, incremental and absolute. Incremental encoders, shown in the top of Figure 8, are only able to determine whether a rotation of the shaft has taken place and increment or decrement their rotation count. Absolute encoders, shown in the bottom of Figure 8, are able to determine the orientation of the shaft at any time (within some angular resolution) due to a specific feedback at each orientation. Typically incremental encoders are less expensive than absolute encoders but are susceptible to errors if counts are missed due to power loss or other factors. This can be a catastrophic problem in a robotic arm assembling a car frame but is less consequential in a small robotic platform like Pheeno. Mobile platforms like Pheeno use encoders to count the number of rotations each wheel has made. This can then be used as feedback to determine how fast the motor is actually rotating the platforms wheels and how far the robot’s body has traveled or rotated. However, this position and orientation estimates are extremely vulnerable to non level surfaces and wheel slip. Both of these problems cannot be remedied by absolute encoders and thus Pheeno uses incremental encoders, specifically quadrature encoders. Unlike standard (one sensor) encoders, which can only determine speed and displacement, quadrature encoders can determine velocity and direction. The major difference here is quadrature encoders can determine the direction of rotation of a shaft. It is possible to use a normal encoder on a motor and trust the encoder is rotating in the direction commanded, however, it is a horrible idea to assume your input direction translates to your output direction. In a small robot like Pheeno if the motors are turned off and allowed to rotate passively, this rotation will be captured correctly by quadrature encoders and will not necessarily be captured correctly by normal encoders. Pheeno uses magnetic quadrature encoders that use hall effect sensors to detect rotational motion of its motors. Hall effect sensors are used because the emitter and sensor do not need to be well aligned and are not effected by lighting conditions like optical encoders. The encoder is mounted on an extended back shaft of a micro metal gear motor which rotates at the speed of the motor before the rotation is geared down to the wheel shaft. This allows for higher resolution measurement of the wheel rotation. (a) Diagram of an incremental (top) and absolute (bottom) optical encoder. (b) Diagram of an incremental quadrature optical encoder (top) and the produced signal (bottom). Figure 8: Encoder diagrams. Figure from \\cite{EncoderFigures}. Infrared Distance Sensors Pheeno uses six Sharp GP2Y0A41SK0F analog infrared distance sensors to sense linear distance of objects around the robot. These sensors were chosen due to their price instead of an expensive Light Detection And Ranging (LIDAR), sometimes referred to as Light Imaging, Detection, And Ranging, sensors. They also do not have issues with ghost echoes like Sound Navigation And Ranging (SONAR) sensors. Five are uniformly distributed radially along the front $180^\\circ$ of the robot with one in the rear. These are made to measure $4$ cm to $30$ cm distances in front of the sensor. However, they can be exchanged with any other IR sensor with JST mounts for different distance ranges (given the power, signal, and ground connections are the same). Figure 9: A cartoon representation of how an infrared distance sensor determines distance of obstacles. A *light emitting diode* (LED) emits a beam of light through a lens which reflects off a surface (S1, S2) and hits a different location on the *position-sensible photo detector* (PSD). Figure 9 shows a cartoon representation of how a Sharp IR distance sensor works. A light emitting diode (LED) emits a beam of light through a lens which reflects off a surface and hits a different location on the position-sensible photo detector (PSD). Based on the location struck by the reflected beam, a distance measurement can be produced. This method of measuring distance has a few drawbacks that should be recognized. The first is, small or very curved surfaces (e.g. a chair leg) can not always be observed by the IR sensor because the initial beam will miss the object or the reflection will miss the PSD. The second reason is, light absorbing surfaces (e.g. darker surfaces) will absorb a lot of the sensing beam and thus will not cause a reflected beam. The final is a common problem in most light based distance sensors. The beam is very thin and thus the sensor must be aligned both in height and orientation with the object to create a reliable measurement. Camera Pheeno has an optional Raspberry Pi Camera attached to the top of the robot which allows visual information to be captured, processed, and or transmitted to other devices. This camera is a five megapixel fixed-focus camera that is able to capture $1080p$ resolution at $30$ frames per second (FPS), $720p$ resolution at $60$ FPS, or lower resolutions at $90$ FPS. These frame rates are possible in theory but in naive practice these frame rates drop due to the robot’s processing capabilities (on board the Raspberry Pi). When performing further processing on the robot, these frame rates drop even further unless more advanced techniques beyond the scope of this document are implemented. Calibration This section will go through the calibration required to use Pheeno’s on-board sensor suite correctly. This is meant as a high level calibration, meaning the misalignment of the sensors and their sensing ranges will be corrected. Typically these sensors should be calibrated to deal with temperature changes and other factors but that will not be covered. Without calibration the on-board sensors could still be used but would yield information with systematic errors constantly. Calibration really only needs to be done to the IMU. The accelerometer calibration will be covered in the Accelerometer Calibration section, gyroscope calibration will be shown in the Gyro Calibration section, and the magnetometer calibration will be done in the Magnetometer Calibration section. Encoders typically work out of the box. Any calibration needed to detect the changes in magnetic or optical field created by the encoder has already been done before purchasing the sensor. Due to this, the Encoder Calibration will discuss common problems that can be avoided with counting incremental encoders and how to transform counts to linear distances traveled by the wheels of the robot. IR distance sensors typically have a conversion factor available in the data sheet that transforms the voltage read to distance, however, it is a good idea to not blindly trusting data sheets and fit distance data to readings on their own. Cameras, like the one on Pheeno, are typically plug and play. However, it should be noted there are auto calibration functions constantly going on in the background of these web-cam like cameras which are actively focusing the picture, letting in an ample amount of light, and auto-balancing the colors. There are ways to do this manually but that will not be covered here. Accelerometer Calibration The data from the accelerometer at rest in the Accelerometer section suggested the orientation of the IMU was not the same as the robot due to manufacturing errors. If this slight misalignment was ignored, the accelerometer would pass biased acceleration information to the robot every measurement. This would cause errors in the orientation calculations as well as acceleration measurements of the robot. A typical mistake made by new robotic users is to simply subtract off this bias measured when the robot is at rest. This does not solve the problem as any acceleration will not be measured in the same reference frame as the robot’s. Even worse, because the gyroscope measures rotational velocity and the magnetometer measures the magnetic field about the same axes, the angular rotation and magnetic field measurements would be in the wrong reference frame as well. To correct this, the same resting accelerometer data from the Accelerometer section will be used. First, the bias in the data must be identified. Here, it is assumed the sensor has additive white Gaussian noise (AWGN). This assumption means any noise in the sensor is uniform across frequencies, can be described by a Gaussian (normal) distribution, and is added to the true signal. To back up this assumption, the resting accelerometer signal in the x-direction from the Accelerometer section is analyzed. Figure 10 shows the single-sided amplitude spectrum of the resting accelerometer data along the x-axis after a fast Fourier transform. This shows the expected spike at zero because the measurement is just a static signal as well as spikes along the rest of the frequencies from noise. This supports the white noise assumption as there are no significant peaks besides the signal. Figure 11 displays the histogram of the measurements along the x-axis from the accelerometer at rest. While there is a small bump on the left tail of the distribution, this still supports the Gaussian noise assumption. From the AWGN assumption, the bias in each direction is the average acceleration along each axis. This bias vector allows the user to identify the roll and pitch angle differences between the reference frame of the IMU and the resting Pheeno’s reference frame. Figure 12 is a cartoon representation of Pheeno in orientations that would create a roll, pitch, and yaw angles. From our single at rest accelerometer measurement it is impossible to calibrate all three angles. Any gravity measurement will wind up on a unit gravity sphere which only requires two angle parameters to describe fully. Another way to think about this is if the z-axis of the robot’s reference frame and the IMU’s reference frame were aligned, any yaw rotation would cause the same measurement of $1g$ along the z-axis. However from this it is still possible to calibrate the roll and pitch offset between the IMU and the robot reference frames. With a bit more mathematical rigor, Pheeno’s IMU oriented in Earth’s gravitational field $\\vec{g}$ undergoing a linear acceleration $\\vec{a_e}$ in the earth’s reference frame will produce a reading $\\vec{M}$ of, :label: AccEq where $\\textbf{R}$ is the rotation matrix that relates the IMU’s reference frame to the Earth’s. Since we are dealing with orientation data where the robot is at rest on a surface parallel to the Earth’s surface, the z-axis of the robot’s reference frame is aligned with the z-axis of the reference frame of the Earth, this equation simplifies to, The rotation matrices that describe the roll, pitch, and yaw rotations shown in Figure 12 are described as, Using these rotation matrices there are six unique rotation orders that can be done to produce the same rotation; $\\boldsymbol{R_y}(\\phi)\\boldsymbol{R_x}(\\theta)\\boldsymbol{R_z}(\\psi)$ (Roll, Pitch, Yaw), $\\boldsymbol{R_y}(\\phi)\\boldsymbol{R_z}(\\psi)\\boldsymbol{R_x}(\\theta)$ (Roll, Yaw, Pitch), $\\boldsymbol{R_x}(\\theta)\\boldsymbol{R_y}(\\phi)\\boldsymbol{R_z}(\\psi)$ (Pitch, Roll, Yaw), $\\boldsymbol{R_x}(\\theta)\\boldsymbol{R_z}(\\psi)\\boldsymbol{R_y}(\\phi)$ (Pitch, Yaw, Roll), $\\boldsymbol{R_z}(\\psi)\\boldsymbol{R_x}(\\theta)\\boldsymbol{R_y}(\\phi)$ (Yaw, Pitch, Roll), $\\boldsymbol{R_z}(\\psi)\\boldsymbol{R_y}(\\phi)\\boldsymbol{R_x}(\\theta)$ (Yaw, Roll, Pitch). These rotation orders are not commutative, like most matrix multiplications, and multiplying them out yields different matrices. To solve for roll and pitch, expanding the pitch, roll, yaw matrix multiplication yields, Using this matrix in \\autoref{eq:AccEq} with $\\vec{g} = [0 \\hspace{0.1cm} 0 \\hspace{0.1cm} -1]^T$ yields, :label: RollPitchEq which is only dependent on the pitch, $\\theta$, and roll, $\\phi$, angles. Using the average measurement vector, it is possible to solve \\autoref{eq:RollPitchEq}. It should be noted that the vector on the right side of \\autoref{eq:RollPitchEq} always has a length of $1$, thus $\\vec{M} = [M_x \\hspace{0.1cm} M_y \\hspace{0.1cm} M_z]^T$ should be normalized. Solving \\autoref{eq:RollPitchEq} for the pitch and roll angles yields, Note that the pitch angle has two negatives that could be canceled. These are left in purposefully so that when solving for the angle and using and atan2() function the user does not get the wrong angle. Now to determine the yaw angle offset, Pheeno is pitched at a known angle like in Figure 12(b). The new measured gravity vector should now be $g = [0 \\hspace{0.1cm} -\\sin(\\theta_d) \\hspace{0.1cm} -\\cos(\\theta_d)]$ where $\\theta_d$ is the known inclination of the robot. Substituting this into \\autoref{eq:AccEq} yields, where $M_p$ is the accelerometer measurement vector when Pheeno is pitched at angle $\\theta_p$. In this equation there is no $\\boldsymbol{R_z}(\\psi_{xyz})$. This is because previously $\\psi_{xyz}$ was not able to be solved for. Thus, it can be chosen arbitrarily. If chosen to be $\\psi_{xyz} = 0$, $\\boldsymbol{R_z}(\\psi_{xyz})$ is a 3x3 identity matrix. To simplify this equation, substitute, This allows for an explicit solution for $\\psi$, The rotation matrix which aligns the IMU’s reference frame with Pheeno’s is then, These angles should be saved. To use this calibration properly, any measurement should be rotated through this matrix. Figure 10: The single-sided amplitude spectrum of the resting accelerometer data along the x-axis. Figure 11: Histogram of the resting accelerometer data along the x-axis. (a) (b) (c) Figure 12: Cartoon of Pheeno at different orientations representing the roll, pitch, yaw convention. Gyroscope Calibration Gyroscopes typically don’t need much calibration. Again, an assumption about the sensor noise should be made. The gyroscope is assumed to have AGWN like the accelerometer. The analysis supporting this assumption is the same as provided in the Accelerometer Calibration section and will not be shown here. Calibrating a gyroscope only requires subtracting a resting bias. This involves simply averaging the gyroscope measurements in each direction when Pheeno is at rest on a level surface, then saving this information and subtracting the average from any reading. It should be noted that the axis the gyroscope measures rotation about are the same as the accelerometer. This means any measurement made by the gyroscope should be transformed to Pheeno’s reference frame through the rotation matrix found in the Accelerometer Calibration section. It is up to the user whether to subtract an average of the transformed measurements from transformed measurements or subtract the average untransformed measurements from untransformed measurements then transforming the result. The latter is preferred but both are valid. Magnetometer Calibration Magnetometers are typically the sensor that requires the most frequent calibration. Like the accelerometer, the magnetometer measures a theoretically constant magnetic field vector with respect to the magnetometer’s orientation. However, these readings can easily be thrown off by large metal beams or wires with large electrical currents in buildings. For larger robots, the motors can cause throw off large magnetic anomalies, however, Pheeno uses very small low current motors so their effects can be ignored. In an ideal scenario, the magnetometer would just read the magnetic field of the earth, which is different depending on the user’s location around the globe. With that said, even if the magnetometer were calibrated at the factory it was produced in, those calibration values would be invalid other places. For this section, it will be assumed the magnetometer is only reading the Earth’s magnetic field. Ways to overcome or recognize anomalies in the magnetic field are possible but will not be covered. The ideal response surface for a 3-axis magnetometer is a sphere centered at the origin. This means if the user rotates the magnetometer while taking readings, a well calibrated magnetometer will produce point readings on a sphere with a radius equal to the magnitude of the magnetic field present. Figure 13(a) shows uncalibrated data taken from the magnetometer on-board Pheeno. The data was taken at 1Hz increments while the sensor was slowly rotated about each axis. The plot is a various 2D slices from the 3D sphere to illustrate the fact that the slices are not centered at the origin and the response sensitivity is different along each axis (they are not equal radius circles). These are often referred to as hard iron and soft iron errors or biases, respectively. Hard iron biases are typically the largest source of error and usually the easiest to account for. To correct this, record the maximum and minimum field measurements along each axis while rotating the magnetometer. Once the user is satisfied the magnetometer has taken sufficient measurements in each orientation, the average between the max and min magnetometer reading along each axis is equal to the hard iron bias in each direction. To correct for the soft iron bias correctly, the response surface from the raw measurements of the magnetometer should be deconstructions into their elliptical principle axis to create a $3\\times3$ correction matrix to transform the general ellipsoid to a sphere. This is pretty involved and more importantly can be approximated in a much easier way. An explanation of the mathematics behind the full calibration method can be found at \\cite{MagnetometerCalibration}. A decent approximation for this process is to simply scale the response along each axis with the maximum and minimum measurements already calculated previously. First a scale factor, $s$, is calculated, where, This average scale factor is then projected onto each axis as a gain, This approximation of the full calibration is a simple orthogonal rescaling; equivalent to a diagonal $3\\times3$ calibration matrix. The calibrated data is then found by subtracting the hard iron bias from the raw measurement in each axis and scaling the difference. For example the calibrated magnetometer reading, $\\vec{M_{cal}}$, of a raw measurement, $\\vec{M_{raw}} = [M_x \\hspace{1mm} M_y \\hspace{1mm} M_z]$, with hard iron bias vector $\\vec{b_{HI}} = [b_x \\hspace{1mm} b_y \\hspace{1mm} b_z]$ and scaling matrix $\\boldsymbol{G} = diag(sx,sy,sz)$ would be, Figure 13(b) shows data taken after calibration. Compared to the uncalibrated data, the circles are now concentric and approximately circular. (a) (b) Figure 13: Several slices of the magnetometer measurements along the principle plains. Motor Encoder Calibration Motor encoders do not require any sort of calibration. However, the data (which is the number of counted rotations) has to be transformed to some usable units. For generality, the encoders will be assumed to count $n$ times per rotation of the extended back shaft and there will be a $g$ gear ratio from the measured extended back shaft to the wheel shaft. From this assumption, the numbers of radians the drive shaft has traveled per count, $x$, would be, From this transformation, the linear distance a wheel would travel [assuming no slipping] and the rotational velocity of the wheel shaft can be calculated. An important note that can cause some issues is these counts become very large very quickly. Usually these counts are stored in an integer variable on board your robot’s processor which only allows n-bit ranges ($2^{n}$). In Pheeno’s case signed integers are stored in a $16$-bit variable. This means signed integers can only be stored from $[-32768,32767]$ once this range is surpassed, the number will roll over. This means if the count were supposed to increment to $32768$ (outside the range) it would actually go to $-32768$. This can cause velocity and position estimates to go haywire if not expected. Standard conditional statements inside the robot’s code can alleviate this issue but users should still be aware of this issue. Sensor Fusion for State Feedback This section will go through complementary filters that are used on board Pheeno to fuse the sensor measurements to determine the robot’s state (position, velocity, orientation, etc.). It will also briefly go into using the sensors that sense the robot’s surroundings (IR distance sensors and camera) to determine reliable information about the environment. The Complementary Filter (Basic) section will go over complementary filtering of sensors in a very basic sense with limited mathematics to give the user an intuition. The Complementary Filter (Advanced) section will introduce complementary filters in a more mathematically rigorous sense. The Complementary Filter Design for Pheeno section briefly describes the complementary filters used on board Pheeno. Complementary Filter (Basic) A complementary filter is an easy to implement sensor filter that joins two state estimates together. These estimates are required to be accurate on different time scales. Meaning that one must be able to capture fast and aggressive changes while the other maintains a consistent reading that will stay correct for long periods of time after the aggressive maneuver (the measurement does not drift). For example, to determine the robot’s orientation about one axis, gyroscope measurements can be combined with magnetometer or accelerometer measurements. The gyroscope is able to pick up quick motions well but after long periods of time will drift and its angle estimates will become wrong, while the accelerometer and magnetometer will determine the correct orientation when the motions are less aggressive. Complementary filters are very similar to proportional, integral, derivative controllers in nature. They are easy and computationally inexpensive to implement on micro controller while still yielding extremely accurate measurements. Their major drawback is they may only fuse two measurements and do not give any intuition about how wrong their measurement estimates may be. The measurements are also required to have strengths in opposite frequency domains which is not always possible. Complementary filters are used on board Pheeno to estimate the robot’s roll, pitch, and yaw angle as well as body linear velocity estimates. For this small, relatively slow robotic platform, complementary filters are found to be just as effective as more advanced Kalman filters at a fraction of the computational expense. These filters work by using high pass and low pass filters simultaneously. High pass filters allow high frequency signals while suppressing low frequency signals (such as drift of the gyroscope). Low pass filters act the opposite way by allowing low frequency signals while suppressing high frequency contents (like vibrational noise picked up by the accelerometer). In its most simple form, a first order complementary filter takes the form, :label: CFBasic where, $m_{filter}$ is the filtered measurement, $m_{fast}$ is the measurement that is accurate over short timescales, $m_{slow}$ is the measurement that is accurate over long timescales, and $a \\in (0, 1)$ is the filter gain that is to be chosen. Choosing $a$ properly requires a bit of mathematics to fully understand but can be chosen and tweaked based on some intuition as well. \\autoref{eq:CFBasic} can be looked at naively as an average. Two measurements are being averaged based on the users confidence in them during short time periods. The higher $a$ is chosen, the more the filtered measurement will rely on the fast measurement and will take longer to return to the slow measurement (which will be true when the aggressive maneuver has ended). The lower $a$ is chosen, the more the filtered measurement will rely on the slow measurement and will be more prone to short term noise. While this is not how these filters were formulated (the idea behind them was not averaging in this sense), it is good intuition to design these filters. The optimal choice for $a$ in a scenario will result in a filtered measurement that is able to capture very fast changes in the measurements as well as not have that measurement drift. As a more concrete example, consider an accelerometer and gyroscope measurement being fused to determine a roll angle estimate. Using the first order complementary filter, the roll estimate at time $t$ after a time step of $\\Delta t$ could be determined by, This example essentially updates the new roll angle estimate, $rollAngle$, by combining $90\\%$ of the gyroscopes update, $gyroRollRate$ with $10\\%$ of the accelerometer’s update, $accRollAngle$. This combination will ensure the measurement won’t drift due to the accelerometer limiting the integration error and will still be accurate in short term estimates due to the majority of the updated estimate coming from the gyroscope. Complementary Filter (Advanced) While the basic complementary filter gives a basic understanding of the complementary filter, this section looks at it with slightly more mathematical rigor. Figure 14 shows an example block diagram of a complementary filter fusing a gyroscopic angle measurement with an accelerometer measurement. The gyroscopic measurement is integrated once to yield an angle then high pass filtered to avoid drift. The accelerometer measurement is low pass filtered to avoid the high frequency noise that plagues accelerometer measurements during fast rotations. When added these measurements complement each other’s weaknesses. Figure 14: Block diagram of a complementary filter fusing a gyroscope angular measurement with an accelerometer angular measurement. Using a first-order high pass and low pass filter, the transfer function in continuous time is, :label: CFCont where $T$ determines the cut-off frequencies. This now must be transformed to discrete time, as robots do not operate in continuous time. Using backwards difference, $s = \\frac{1}{\\Delta t}(1-z^{-1})$, in \\autoref{eq:CFCont} leads to the final equation, :label: CFGyroAcc where, $\\alpha = \\frac{T}{T+\\Delta t}$. Note, this is the same as \\autoref{eq:CFBasic}. This still begs the question, how should the cut off frequency be chosen? The answer is an optimization problem which is beyond the scope of this paper and usually needs to be adjusted in application if the optimization is done. The filter needs to be designed such that there are constant amplification and small phase loss of all measurements. More specifically, this means setting the cut off frequency high enough such that the largest range of frequencies is measured by the accurate but noisy sensor with slow dynamics (accelerometer, magnetometer, etc.). This avoids the drift typical in faster sensors. When motions occur that are at higher frequencies than the dynamics of the slow sensor, the cut off frequency should be set low enough such that the expected phase loss of the slower sensor is compensated by the faster sensor (gyroscope, encoders, etc.). It should be noted on a small slow robotic platform like Pheeno, it is possible to set only one cut off frequency and get reliable measurements. However, in faster more agile systems like quad rotors, more advanced techniques like a gain-scheduled complementary filter are required. This filter switches it cut off frequency or other design parameters depending on how aggressive a measured action is (acceleration measurements). There is also another representation of a second order complementary filter based on the Mahoney and Madgwick filter for more agile systems that can be used over a first order filter to capture more advanced dynamics \\cite{GainScheduleFilter,MadgwickFilter, MahoneyFilter}. Complementary Filter Design for Pheeno Pheeno uses complementary filters to determine its orientation angles (roll, pitch, yaw) as well as its linear velocity. This involves fusing the robot’s sensors with slow dynamics accelerometer, magnetometer) with its fast drifting sensors (encoders, gyroscope). Using the same convention established in the Accelerometer Calibration section, the accelerometer’s measurements is combined with the gyroscopes measurements to determine roll and pitch angles of the robot. The magnetometer angular measurements are combined with the gyroscopic measurements to determine the yaw angle of the robot (heading). The accelerometer is combined with encoders to determine the robot body’s velocity. This design mostly comes from experience working with the sensors and in application the best way to determine filter coefficients is to tune on a data set and gain intuition about the sensors from their data outputs. It is possible to model the sensor and determine these cut off frequencies in a more mathematically rigorous fashion but, when working with inexpensive robots with readily accessible parts, this method is faster with just as valid results. (a) (b) Figure 15: Orientation angle estimates from several sensors and a filtered combination while Pheeno was manually pitched about $45^{\\circ}$ at different rates. (a) Accelerometer (blue), gyroscope (black), and complementary filter (red) estimate of Pheeno’s pitch angle. (b) A zoomed in section of (a). Figure 15 shows the time evolution of the angular orientation estimate for Pheeno about its x-axis (pitch) as it was manually pitched from a level table to about $45^{\\circ}$ over different periods. The filter take the form of \\autoref{eq:CFGyroAcc}. To determine the parameter of the complementary filter equation, $\\alpha = \\frac{T}{T+\\Delta t}$, refer to Figure 15(b). This data was sampled at $100$ Hz so $\\Delta t = 0.01$. This leaves $T$, the time constant of the system. A rule of thumb used here is to determine the time when the fast sensor, in this case the gyroscope, drifts out of the error of the slow sensor, in this case the accelerometer, when the system is at rest and the slow sensor’s measurement is correct. For this case Figure 15(b) shows the gyroscope’s pitch estimate drifting outside the $0.01$ rad error envelope of the accelerometer after $1$ s. Plugging this into the equation for $\\alpha$ yields, $\\alpha = 0.99$. A similar process is done for each axis of rotation on the robot. Further analysis of Figure 15 gives a good idea of how this fusion is performing. It is very apparent the pitch estimate from the gyroscope (black line) is drifting away from the true rotation range but is still capturing the rotation rate correctly especially during higher frequency rotations like between $t = 65$ s and $t = 70$ s. The accelerometer’s estimate (blue line) is not drifting but there are very apparent spikes when the robot makes contact with the table again and during the high frequency rotation between $t = 65$ s and $t = 70$ s. The complementary filter with $\\alpha = 0.99$ captures the best of both of these sensors. There is no apparent spiking or noise from the accelerometer measurements and the estimate is not drifting. Figure 16: A top view of Pheeno with red trapezoids superimposed to represent the infrared distance sensing skirt."
					}

					
				
			
		
			
				
					,
					

					"pheeno-pheeno-construction-content": {
						"id": "pheeno-pheeno-construction-content",
						"title": "Pheeno Construction Guide",
						"category": "",
						"url": " /pheeno/pheeno_construction_content/",
						"content": "Introduction The “Pheeno” is a modular robot developed by the Autonomous Collectives Lab at Arizona State University in the spring of 2015 for usage in bio-inspired engineering collectives. The goal of the ACS lab is to develop control frameworks for multi-robot systems; however, Pheeno is a small, versatile robot that can be used in any number of settings, whether individually or in groups. This robot itself is a two-wheeled, cylindrical device controlled by an Arduino Pro Mini and Raspberry Pi with the opportunity to develop modules to be added on to the robot. A completed Pheeno robot can be seen in Figure 1.1. (a) View from the back. (b) View from the top. Figure 1.1: Completed Pheeno. This guide will give step by step directions for constructing the Pheeno along with detailed photos and descriptions of the parts necessary. We at the ACS lab are glad you have chosen to take the time to build this robot, and we wish you the best of luck. PCB Assembly The first and possibly most difficult stage of the Pheeno construction is the assembly and soldering of parts onto the custom-designed printed circuit board (PCB). The A diagram of the PCB is shown in Figure 2.2; consult it carefully in conjunction with the pictures and descriptions below (an electronic schematic can be provided upon request). The population of the board takes approximately two hours, and the final result is Figure 2.1. (a) View from the top. (b) View from the bottom. Figure 2.1: Completed Printed Circuit Board. Figure 2.2: Wiring diagram for the PCB of Pheeno. IR Mounts The mounts for the IR sensors must first be constructed. The components can be seen in Figure 2.3(a) Pull out three pins from a row of male breakaway pins, crimp them into Molex 22-30 gauge crimp contacts, and insert each pin into a 3-pin female header. Start with empty PCB board. Insert six mounts, which will hold the IR sensors, along the outside of the board with the pertruding tabs facing outwards, as shown in Figure 2.3(b). It is crucial that the mounts face the correct direction, otherwise the IR sensors will not point outwards. Flip the board over and carefully solder the pins. Clip off the excess length. Note: The thicker pins tend to prevent the heated rosin from flowing effectively, occasionally causing the solder to bridge two pins. Make sure the pins are not shorted out. (a) IR Mount Components (b) PCB with IR mounts inserted Figure 2.3: IR Mounts. Resistors The next step is inserting and soldering the resistors found on the board. Before beginning, it is helpful to gather the necessary types of resistors. The number and size of the resistors needed is shown in Table 2. Bend the leads tightly so that they fit into the holes, and in general follow the wiring diagram from the previous page very carefully. Bend the wires along the back surface of the board to secure each resistor, then solder each hole. Finally, clip the excess wire. Figure 2.4(a) shows the PCB populated with resistors. Resistor Resistance 121 10k 49.9k 1M 200 61.9 400 Number Required 8 6 6 5 4 1 1 Table 1: Resistors required for Pheeno's circuit board. Capacitors Next the capacitors should be soldered to the board. You should always check if the capacitors are electrolytic tantalum or ceramic film! Electrolytic tantalum capacitors have polarity associated with them, meaning a specific lead needs to be grounded. In general capacitors below $1 \\si{\\micro\\farad}$ are ceramic film and thus can be put in either direction. With the capacitors used in the purchasing sheet provided, the 10 (\\si{\\micro\\farad}) capacitors are electrolytic and the rest are ceramic or film. This means that they must be oriented correctly, with the silver side (negative lead) oriented as seen in Figure 2.4(b). If you are using the schematic the negative lead should be soldered to ground. Insert them in the correct spots and bend the wires back to hold them in place. Make sure the capacitors are pressed as much as possible into the board; this provides less probability of shorts, does not make the board tall, and allows for other components to fit over the capacitors. Figure 2.4(b) displays the population of the PCB with resistors and capacitors. Capacitor Capacity 0.1 10 1 Number Required 11 5 2 Table 2: Capacitors required for Pheeno's circuit board. (a) (b) Figure 2.4: PCB with (a) resistors inserted and (b) resistors and capacitors inserted. Molex Connector Pins, Male Breakaway Pins, and Op-Amp On the left side of the PCB, to the right of the tightly packed rows of resistors lie 16 holes. Insert into these holes four 4-pin Molex connectors with the tall plastic edge located on the interior side, namely towards the printed words on the board. Each of these connectors will eventually be connected to an LED. Flip the board over and solder the pins securely into each hole. Similarly, two 2-pin Molex connectors can be found at the bottom left of the board. Refer to Figure 2.5 for the correct orientation. One of these connectors runs to the switch for turning the robot on and off. The other connector is an optional set of power pins directly from the Op-Amp circuit that can be used to power attachment boards. Once again flip the board over and solder the white connectors. Next up, solder several sets of loose breakaway male pins into the board. Insert three connected pins on the lower left-hand side of the board above the “RGB” text; these will eventually connect the LED’s to the Raspberry Pi for control of the lighting. In the middle of the board use another set of three pins. These pins connect to the camera servo. Lastly, solder two pins on the upper left-hand side. Wires from these pins power the Raspberry Pi. A useful tip for soldering these pins is to insert the long edge into a block of foam, that way the pins do not fall out or get oriented incorrectly when the board is flipped for soldering. A quick component to insert is the Op-Amp. It is the black chip on the lower section of the board depicted in Figure 2.5. Make sure when inserting it the notch is facing the same direction as in the picture! Figure 2.5: Layout of Molex connectors, male headers, and Op-Amp. Premade Boards The trickiest part of the PCB may be soldering the attachments of the three boards, the Arduino Pro-Mini, the compass accelerometer (also referred to as an IMU), and the H-bridge motor controller. The accelerometer is likely the easiest of the three to mount, so start there. Each accelerometer package comes with a set of pins, as can be see in Figure 2.6(a). The male header pins should be soldered such that the text is facing the soldered ends and the hole is in the lower right when looking at the soldered ends. Insert the board into the PCB such that it covers the “Accelerometer” text on the PCB, as seen in Figure 2.7. Balance the accelerometer parallel to the PCB and solder each hole. Clip off the excess length from the pins. (a) Accelerometer Compass (b) Motor Board (H-Bridge) (c) Arduino Pro Mini Figure 2.6: (a) Compass Accelerometer, (b) Motor Board (H-Bridge), (c) Arduino Pro Mini with male header pins soldered to them and free male header pins around the perimeter showing how many were used. Figure 2.7: Layout of the accelerometer compass, motor board, and Arduino Pro Mini. The H-Bridge motor controller is the red board, as seen in Figure 2.6(b). Clip off two sets of 8 male header breakaway pins and insert them into the PCB. The pins should be put through such that the chip on the board is facing the side soldered. Insert the board into the PCB such that the larger chip faces the top the PCB as seen in Figure 2.7. Flip the PCB over and solder the motor board to the PCB. Last but not least is the Arduino Pro-Mini. Solder two sets of 12 male header pins to the board, along with two sets of 2 pins, as seen in Figure 2.6(c). The pins should be soldered such that the soldered side faces the chip and reset button. In addition, solder 6 right angle male header pins into the holes on the shorter edge of the board. It would seem intuitive to then insert and solder the set-up directly into the PCB; DO NOT DO THIS. Instead insert the same number of female header connectors into the PCB. This extra set of connection allows one to remove the Arduino Pro Mini if necessary and have the right angle headers not interfere with the IMU. Finish connecting and orienting the Arduino as seen in Figure 2.7, with the reset button pointing towards the top of the PCB. Large Miscellaneous Components Up until this point the components inserted into the board have been mostly flat and symmetrical, permitting a balanced surface for soldering the backside of the PCB. However, the remaining components, primarily transistors and voltage regulators (switching DC DC converters), come in a variety of shapes and sizes. First up are the three 5V switching regulators. Orient these as seen in Figure 2.8(a); they are marked by the “5V boxes” on the wiring diagram. The massive variable regulator (set to 6V) should be inserted on the lower right. It can only fit into the PCB one way. Solder all of these parts carefully so nothing is shorted. Next up are the three 60 V FET’s (Field Effect Transistors) on the left. Orient the small devices as seen in Figure 2.8(a). A fourth FET, rated at 40V, should be inserted next to the lower 5V regulator. Lastly, three large $1000 \\si{\\micro\\farad}$ capacitors should be soldered in. Similar to the $10 \\si{\\micro\\farad}$ capacitors, the leads must be connected to the correct voltage lines to function (and not pop!). The silver strip points to the left on the upper two and to the bottom on the bottom one. (a) (b) Figure 2.8: Top of the PCB with (a) 5V switching voltage regulators inserted and (b) 5V switching voltage regulators, $1000 \\si{\\micro\\farad}$ capacitors, and variable regulator inserted. Congratulations, the top side of the board is complete! Check all the components inserted so far and make sure no solder rosin has bridged pins alongside the bottom of the board and no pins are left unsoldered. Underside of Board We are close to finishing the PCB. Insert and solder two 6-pin Molex male connectors along the bottom of the board, as seen in Figure 2.9(a). These pins run to the wheel encoders and motor driving lines, so make sure they’re oriented correctly, with the tall white edge towards the center of the board. (a) (b) Figure 2.9: Completing the bottom of the PCB with (a) the 6 pin Molex connectors inserted and (b) the power wire inserted. A power cable must be constructed. Figure 2.10 shows the stages involved in making the jumper cable. First, solder 22 or 20 gague red and black wires to the positive and negative leads of an XT60 male connector. Then, to insulate the leads, use heat shrink wrap to cover the newly soldered leads. Cut the red and black wires to the same length, strip the ends, and insert the wires into the two remaining holes on the PCB (marked $+$ and $-$). Make sure the positive XT60 socket is connected to the $+$ labeled hole and the negative XT60 socket is connected to the $-$ labeled hole. Lay the cable across the back of the board and solder the exposed wire into each hole. To resist wear and possible snapping of the wire at the PCB solder point, we will create a new pivot point for the wire on the board. With the wire pressed against the PCB use hot glue or some other stretchy adhesive to secure the middle of the wire against the board. We use hot glue seen in Figure 2.9(b). (a) (b) (c) (d) Figure 2.10: Stages of constructing jumper cable. Chassis Assembly 3D Printing Most of the robot chassis is 3D printed. These designs were printed on a MakerBot 2X using standard ABS plastic with 12% infill. Other plastics and printers have not been tested though should work. Most of the holes are meant to be self threading screw holes so harder plastics could cause issue here. For the chassis, the following files should be printed. Core Module rear_column3.stl (x1) rear_column3_mirror.stl (x1) front_column3.stl (x1) front_column3_mirror.stl (x1) battery_bracket_lipo.stl (x1) drivetrain_bracket.stl (x1) Camera Module cameracase_back_tilt.stl (x1) cameracase_front_tilt.stl (x1) servo_tilt_bracket.stl (x1) tilt_bracket_core.stl (x1) Motor Encoder Wheel The fabrication of the motor encoder wheel assembly requires some of the most precise soldering necessary in the course of constructing Pheeno. The first step is to gather the parts and understand their function and behavior. The parts for assembly can be seen in Figure 3.1(a) (Note: This picture does not contain all of the female connection terminals). The $50$:$1$ micro gear brushless motor is very small with a small extended motor gear shaft out of the back which will be used for the encoder readings. The magnetic encoder PCB consists of the small green board and associated magnet; this PCB relays voltages to the motors and records the rotations of the extended gear shaft using Hall sensors. The ribbon cable connects the encoder to the main PCB on Pheeno. As seen in Figure 3.1(b), carefully solder the ribbon cable to the encoder board. The cable should be soldered to the text side of the board, with the brown wire soldered in the hole labeled GND. If you are using different colored wires, make sure the wires are connected the same way as displayed in Figure [3.1](pheeno_construction_content#fig3_1a). In addition, the wires should bend away from the center of the board, to allow the magnet room to rotate. The board itself can now be soldered onto the motor. The wires should run away from the motor chassis and the words stamped on the motor should be on the same side as the wire leads, as seen in Figures 3.1(c) and 3.1(d). Two pins atop the motor fit into the large holes in the board. Make sure the board lies flat and parallel to the motor when soldering. A trick to do this is to solder one terminal then keep it warm such that the solder is still liquid and reposition the board with pliers. BE CAREFUL NOT TO BURN YOURSELF DOING THIS! YOU DON'T NEED TO USE YOUR FINGERS YOU CAN USE PLIERS! I AM NOT RESPONSIBLE FOR YOU TOUCHING LIQUID SOLDER OR THE IRON!. Attach the magnet on the motor shaft above the encoder, leaving a little bit of space for free rotation. Typically, the magnetic disc can be put on the extended gear shaft and pressed to a flat surface. The wheel, consisting of the plastic well and a separate tread can be pushed onto the main motor shaft, as seen in Figure 3.1e. Lastly, the end of the ribbon cable should be crimped with female connectors that will be inserted into the Molex 6-Pin female housing. Crimp six 22-30 gauge connectors onto the ends of the ribbon cable. If one considers the cable from left to right with the ground wire (brown) on the left, then the white female connector should fit on the wire with the tabs facing into the table. It is crucial that the female connector fits on in this orientation, attach the six 22-30 gauge pins accordingly, and reference Figures 3.1f, 3.1g, and 3.1h. Repeat all of the steps above to make the second motor assembly. (a) (b) (c) (d) (e) (f) (g) (h) Figure 3.1: Steps for constructing wheel sub-assembly. Drivetrain Now that the two motors are complete, they can be mounted to the chassis. Using a 3D printer, print the cross-shaped chassis component. Once the part is finished, make sure to remove the raft from the printed component; this extra bit of extruded plastic is not part of the mechanical design. Ream the holes to clear excess plastic. Gather the other necessary components. Two caster assemblies are needed in addition to the two wheel assemblies just created. The parts are shown in Figure 3.2(a). (a) Parts of the drivetrain assembly. (b) Assembled drivetrain. Figure 3.2: Completing the drivetrain. First, assemble the Pololu casters. The process can be seen in Figure 3.3 and will be referred to through this paragraph. Place the triangular black piece flat on the table with the opening facing out and insert the metal ball, as seen in Figure 3.3(a). Next insert the three tiny metal rods that keep the ball in place, as shown in Figure 3.3(b). Lock the loose components in with the flat triangular piece, shown in Figure 3.3(c). The ball should feel secure but still have a full range of motion without resistance. Screw the assembly onto the triangular extrusion on the chassis mount, as seen in Figure 3.3(d). Repeat these steps for a second caster, then attach it it on the opposite end of the 3D printed part, shown in red in Figure 3.3(d). (a) (b) (c) (d) Figure 3.3: Constructing and mounting the casters to the drive train. The motors will be mounted next. The parts required can be seen in Figure 3.4(a). Each bracket should fit snugly on the exposed gearing portion of each motor. This bracket aligns with the holes on the edge of the chassis piece, so place the tiny nuts in the hexagonal slots in the bracket and screw the bolts in. As seen in Figure 3.4(b), the flat edge of the encoder should be facing away from the cross-shaped chassis. Figure 3.4(c) displays the entire set-up with both motors mounted. (a) (b) (c) Figure 3.4: Attaching the motors to the drivetrain. Mounting We are close to being done with the chassis and full assembly! The only two components left are the Pheeno base board (a laser-cut acrylic disc with slots in it), and the 3D printed battery bracket. Note that the bracket can be rather fragile, so take care not to snap off the protruding tabs! The base board is sandwiched between the drivetrain assembled previously and the battery bracket. These parts are shown in Figure 3.5(a). There are four holes that align in each of the three components (two in the middle and two at the front of the bot); screw a bolt through each of them to attach the three components. Unfortunately, due to 3D printing errors, these holes frequently don’t align within a very feasible tolerance, so feel free to ream out the holes as necessary. Figures 3.5(b) and 3.5(c) show the bottom and top of the assembly when it is put together. As seen in Figures 3.5(b) and 3.5(c), the ribbon cables slide through a side slot in the base plate. Make sure that the connectors end up on the side of the battery bracket with a tab by the opening; the encoders can then more easily be wired to the PCB. Unfortunately the female connectors on the ribbon cables do no fit through the slots well on the acrylic base plate. It is therefore necessary to use a rotary saw (likely a Dremel) to lengthen the slot to fit the connectors through. The final result is shown in Figures 3.5(b) and 3.5(c). Another way to do this is to insert the wires into the 6-Pin Molex connector, as shown in Figure 3.1, after slipping the wire through the smaller hole if you do not have access to a cutting tool. (a) Base Parts (b) Bottom View (c) Top View Figure 3.5: The base of the chassis assembly. Robot Interior PCB Mounting The base of the robot is finished, so we can build up from it. The next important stage is attaching the PCB developed in Section 2. The side walls of Pheeno consist of two pair of 3D printed columns. The narrow columns attach in the back of Pheeno, namely the side with the battery bracket opening. The tabs should face inwards and be on the side of the column closes to the back as seen in Figure 4.1(a). The rectangular holes in the column should be near the base of the robot, as seen in Figure 4.1(b). Meanwhile, the wide columns are located in the front of the robot. The wide slots in these columns serve as openings for the IR sensors. These columns should be mounted such that the tabs are facing inwards and towards the front of the robot with the wide opening away from the base of the robot. The finished assembly are shown in Figures 4.1(a) and 4.1(b). Take the PCB assembled in Section 2 and slide it into the Pheeno with the Arduino positioned towards the front (the columns with the IR openings). The male pins extruding from the bottom of the board should be positioned near the female connectors on the ribbon cable. Screw the PCB onto the tabs of the columns. Be careful not to snap off the mounting tabs by pushing too hard! Do not be concerned if the columns bow a bit, this is normal. Connect the encoder cables to the PCB assembly with each cable oriented on the side its associated motor is located. Namely the ribbon cable from the left motor should slide into to the left-hand male connector, and vice versa. If these are switched, Pheeno will drive opposite the expected direction. (a) (b) (c) (d) Figure 4.1: Assembly of the interior of Pheeno. Switch Construction The square slots in the rear columns can fit an on-off switch for Pheeno. The switch assembly connects to two pins on the PCB and more easily allows for disconnecting the power than unplugging the battery would. The assemble process is shown in Figure 4.2. The first step is fitting a wire through the hole in the back of the switch, as shown in Figure 4.2(b). Solder this connection (Figure 4.2(c)) and then heat shrink it to insulate it (Figure 4.2(d)). It doesn’t matter which wire connects to which pin; the switch is simply a breakpoint in in the circuit. Repeat the process with another wire for the other pin. At this point the switch should look like Figure 4.2(e). Similar to the 6-Pin Molex connector made in Section 2, Figure 3.1(g), crimp two 22-30 gauge female connector terminal to the opposite ends of the wire. Insert these wires into a 2-Pin Molex female housing as seen in Figure 4.2(f) to complete the switch assembly! (a) (b) (c) (d) (e) (f) Figure 4.2: Steps for assembling switch wire. To attach the switch to Pheeno, refer to Figure 4.5. Slide the connector through one of the columns into the interior of the Pheeno. The physical switch should fit securely in the column but can wiggle around and still pop out with enough force. You can secure it further with some hot glue. Run the wire under the PCB and loop it back on top to the pins by the rear IR sensor. Ensure that the connection is at the lower set of pins, as seen in Figure 4.3(b). The switch wire can be run from either column in any secure way to the pins on the PCB, just make sure it cannot block an IR sensor or interfere with any circuitry. (a) Switch in column. (b) Switch Wire Connection to PCB. Figure 4.3: Connecting the switch to Pheeno. LED Construction A useful user feedback indicator of Pheeno’s behavior, such as driving, gripping, lifting, etc, is to associate each behavior with an LED color. The holes in each column serve as spots for four multi-color, common anode LED’s. Of course, these bulbs need a manner of attachment to the PCB. The construction of this LED sub-assembly can be seen in Figure 4.4. Take the long lead of an LED bulb and wrap the stripped end of a 3in piece of red wire about it to make a solid physical connection (Figure 4.4(b)). This is a similar technique as if you were soldering two wires together. Solder this connection together by carefully coating the twisted connection (Figure 4.4(c)). Cover the exposed wire with a similarly sized length of heat shrink wrap (Figure 4.4(d)). The result can be seen in Figure 4.4(e). Repeat the process with black wires for the other three leads. The finished result is shown in Figure 4.4(f). On the opposite end of the wires, crimp a 24-30 gauge female connector onto the exposed metal for each one, ash shown in Figure 4.4(g). Then insert these connectors into a 4-Pin Molex female housing. Note that the orientation of the connector is important; with the tabs pointed towards the table the first two wires should be black, and the third red! This orientation can be seen in Figure 4.4(h). Repeat the process for three more LED sub-assemblies. (a) (b) (c) (d) (e) (f) (g) (h) Figure 4.4: Steps for constructing LED sub-assembly. With these four LED’s in hand (Figure 4.5(a)), insert them one by one into the Pheeno PCB. As seen in Figure 4.5(b), the white female connectors fit on the male connectors on the left side of the board. Note the location of the red wires! (a) (b) Figure 4.5: (a) Finished LED Assembly and (b) LED Connections to PCB. Miscellaneous The first step of Section 2, in constructing the PCB assembly, was to insert the six IR mounts. It is now time to attach the six associated infrared sensors. Figure 4.6(a) displays the location of the six sensors from an overhead view, with five oriented on the front and sides of Pheeno. It is necessary to clip the “ears” off the IR sensors to fit all of them side by side. The last sensor fits in the rear, next to the switch cable. Figure 4.6(b) shows a head-on view of Pheeno with the sensors inserted. (a) Top View. (b) Front View. Figure 4.6: Connecting the IR sensors to the PCB. The last step for constructing the interior of the bot is to attach the FTDI board, shown in Figure 4.7. This board is a USB-to-Serial integrated circuit and serves to allow communication between the Arduino Pro Mini and the Raspberry Pi. It also allows the Raspberry Pi or an external computer program the Arduino Pro Mini. Connect a micro-USB to USB cable to the FTDI (Figure 4.7(b)), then connect the board to the male header pins on the Arduino (Figure 4.7(c)). The orientation can be seen in Figure 4.7(d). (a) FTDI Board. (b) USB Connection. (c) Top View. (d) Connection. Figure 4.7: Attaching FTDI Board to Arduino Pro Mini. Sweet, you have completed the interior of Pheeno! You are close to having a fully fabricated robot. Robot Top Raspberry Pi Attachment The top of the robot is simply a Raspberry Pi attached to another laser-cut acrylic plate. Figure 5.1 displays the assembly steps. Note that this section is dedicated for assembling the hardware; chapter 6 gives the details on setting up the software on the Pi! The Raspberry Pi is a small, linux computer developed for educational purposes. It often serves as the brains of DIY projects, and in the case of Pheeno is a practical means for doing high level computations like image processing and controller algorithms. The Pi attaches on the underside of the acrylic plate with the GPIO (General Purpose In-Out) pins aligned with the slot in the plate, as seen in Figure 5.1(c). The holes in the plate should align with the mounting holes in the Pi. Using four bolts, nuts, and 1in nylon spacers, fasten the Pi securely as seen in Figures 5.1(c) and 5.1(d). (a) Raspberry Pi. (b) Parts. (c) Top View. (d) Side View. Figure 5.1: Assembly of the top of Pheeno. Top Plate The brains of the bot can now be put on Pheeno. Insert the USB cable from the FTDI into any of the open USB ports on the Pi, as shown in Figure 5.2(b). The slot in the top plate aligns with the slot in the base plate. In order to power the computer, run cables from the PCB to the Pi. BE VERY CAREFUL AND PRECISE WITH THIS; A MISTAKE WILL CAUSE THE PI TO FRY! Fit a red wire with two female headers on the pin marked with a “+” on the board and a black wire on the one marked “-“. These pins are located next to the LED connection and behind the front left IR sensor. The red wire runs to the top right pin on the Pi, while the black runs to the third pin down on the right. If you are unsure with the connection to the Raspberry Pi, refer to a GPIO pin out reference. The red wire should run to a 5V power pin and the black wire to a ground pin. Reference Figures 5.2(c) and 5.2(d) for a visual guide. (a) Parts. (b) USB to Pi. (c) Pi Power Wires. (d) Top Attached. Figure 5.2: Attaching the top of Pheeno. Finishing Touches The last step is to attach the battery. The Pheeno uses is a 11.1V, 3S, 3000 mAh Lithium Polymer (LIPO) battery, which fits into the bracket on the lower side of the robot. Connect the XT60 connectors from the PCB jumper cable and the battery. As seen in Figure 5.3, the battery fits snugly into the slot but can easily be removed and replaced as necessary. Hit the switch and the LEDs on the top right of the Raspberry Pi should start blinking. Congratulations, you have built a fully functioning robot! If you want to start programming Pheeno, refer to the Raspberry Pi set up guide! If you are eager to begin work on a module for Pheeno, refer to the separate module development guide. But once again, thank you for reading this guide so far and following these steps, we at ACS Lab hope you enjoy working on and with Pheeno! If you have any comments, concerns, questions do not hesitate to contact us! (a) (b) (c) Figure 5.3: Final attachments."
					}

					
				
			
		
			
				
					,
					

					"pheeno-pheeno-programming-content": {
						"id": "pheeno-pheeno-programming-content",
						"title": "Beginning to Program Pheeno",
						"category": "",
						"url": " /pheeno/pheeno_programming_content/",
						"content": "One of the processors on board the Pheeno robotic platform is the Arduino Pro Mini with the ATMega328 (3.3V, 8MHz) processor. This section of the guide will introduce how the sensors and motors on the robot are controlled by this processor. It will also walk you through small codes to make the robot move around and sense its environment. This guide will focus heavily on premade libraries and code available on the GitHub repository for Pheeno. These codes and libraries are not necessary for the operation of Pheeno in the long run but do allow for easier coding with subroutines for making the robot drive around using open and closed loop control. If you are new to Arduino programming and general electronics, the next section may not be very informative and can be skimmed over. If you are experienced in Arduino coding, the next section gives details on how the sensors and motors are connected to the Arduino so you can develop your own scripts. If you run into issues with programming the Arduino, there are plenty of resources available at the Arduino Forums and specifically on the Arduino Pro Mini. Of course, always feel free to contact the e-mail above with any questions or issues! General Pin Information for Connection between the Arduino and Motors and Sensors If you want to create your own code and bypass the premade libraries this section will explain briefly how Pheeno’s sensors and motors are connected to the Arduino! Table 1 gives a general overview of how the pins of the Arduino Pro Mini are connected to the various sensors and actuators. Component Connected Pins Pin Type Left IR Range Sensor A2 Analog Left Forward IR Range Sensor A1 Analog Center IR Range Sensor A0 Analog Right Forward IR Range Sensor A6 Analog Right IR Range Sensor A7 Analog Back IR Range Sensor A3 Analog LSM303D (Accelerometer Magnetometer) A4, A5 SDA, SCL Left Encoder 3, 12 Digital Interrupt, Digital Right Encoder 2, 13 Digital Interrupt, Digital Left Motor 5, 6, 7 Digital PWN, Digital, Digital Right Motor 11, 9, 10 Digital PWM, Digital, Digital Camera Servo 4 Digital Table 1: Pheeno's component connections to the Arduino Pro Mini. The IR range sensor data is relatively straight forward. The analog voltage input is taken in through the 10 bit ADC converter measured from ground to VCC. The conversion from voltage to distance is fairly linear until the extremes of the sensor. An example conversion can be found in the readIR function of Pheeno.cpp. This conversion was found experimentally so feel free to find your own conversion if you find it is too inaccurate. The LSM303D is a board within Pheeno that contains an accelerometer and magnetometer. It sends data to the Arduino through I2C communication. Some example files on how this communication is done are in the LSM303D library. Additional information can be found through a supplier of the board, Pololu. The left and right encoders make use of the external interrupt pins available on the Arduino Pro Mini. These encoders can be used as normal encoders with 6 counts per revolution only using the sensors connected to the interrupt pins. They can also be used as quadrature encoders using both sets of pins. The encoder library supplied is highly recommended for quadrature encoder use. The left and right motor are controlled using PWM control for a pseudo analog signal and a H-bridge motor board to control the direction. Pins 6 and 7, for the left motor, and 9 and 10, for the right motor, may be driven to opposite voltages (HIGH and LOW) to determine the direction of motion or both HIGH to “short” the motor providing a brake. Pins 5 and 11 are PWM pins that determine the speed the motor. The Arduino uses a range of 0-255 to regulate the duty cycle of the PWM signal. Subroutines forwardL, forwardR, reverseL, reverseR, brake, and noMotion in the provided Pheeno arduino library (Pheeno.h, Pheeno.cpp) may be viewed as example motor functions. The camera servo is controlled by pin 4. The servo library is highly recommended for its use. Getting Started This section will give a brief introduction to installing the Arduino program to your computer, uploading a script to Pheeno, and installing the premade libraries onto your computer. Installing Arduino If you do not have the Arduino software on your computer, first go to the Arduino software download page. Download the appropriate software for your operating system and install it! Installing the Pheeno Libraries To use the premade libraries for Pheeno you must first download the files and place them in the right place on your computer so the Arduino software can access them. From the GitHub repository for Pheeno download the Code folder. Inside this folder should be an Arduino subfolder with folders labeled Encoder, LSM303, and Pheeno. Copy those three folders to your Documents Arduino libraries folder. Now open the Arduino software. If all was done correctly, when you go to File –&gt; Examples, you should see Encoder, LSM303, and Pheeno at the bottom (you may have to scroll down if you have a lot of arduino libraries already)! If this does not work or the above instructions are unclear, it is recommended to look through the Arduino Library Guide. Uploading Your First Script There should be a USB chord coming out from the Pheeno robot to the Raspberry Pi. This chord allows for serial communication between the Raspberry Pi and the Arduino (and the programming of the Arduino from the Raspberry Pi but this will be explored later). This USB chord can also be used to program the Arduino Pro Mini directly from your computer. Plug the USB into your computer and allow the drivers to install. Once the drivers have installed, open the Arduino software. Go to the Tools tab of the Arduino software and change the board to the Arduino Pro or Pro Mini as seen in Figure 1a. (a) Changing the Board of the Arduino software. (b) Changing the processor of the Arduino software. (c) Changing the port of the Arduino software. (d) Uploading a script to Pheeno. Figure 1: Steps to upload an Arduino script to Pheeno. Next, go to the Tools tab of the Arduino software and change the processor to the ATMega328 (3.3V, 8MHz) as seen in Figure 1(b). Finally, go to the Tools tab of the Arduino software and change the port to the one that the robot is plugged into. Typically there should only be one unless you have another USB device that uses serial communication connected. An example can be seen in Figure 1(c). NOTE: The number associated with the port may not be the same! Now the Arduino software knows what type of board to talk to and through what port. So now you can upload any code you want! To test this all out let’s upload an example script that will be explained later. Go to File –&gt; Examples –&gt; Pheeno –&gt; RandomWalkObstacleAvoidExample. This should load a premade script if you have done everything in “Installing the Pheeno Libraries” section correctly. Now click the arrow in the upper left hand corner of the Arduino software to upload it to the robot. NOTE: THIS SCRI#PT MAKES PHEENO RUN AROUND RANDOMLY! MAKE SURE YOU'RE HOLDING THE PLATFORM SO IT DOESN'T RUN OFF THE TABLE OR MAKE SURE THE ROBOT IS OFF WHILE UPLOADING! When the Arduino software says “Done uploading”, as seen in Figure 1(d), you can disconnect the robot and let it run around. Pheeno Arduino Library Functions If you plan on using the Pheeno library for the Arduino, you can take advantage of some premade functions! This section details what they do and what inputs they take briefly! To use the Pheeno library in any Arduino script, you must first include the necessary libraries shown below! include \"Pheeno.h\" Pheeno myRobot = Pheeno(1); This allows you to use all of the premade functions defined in Pheeno.h and Pheeno.cpp. The Pheeno file that is imported is a premade class. To initialize this class properly you must declare it like is done in the second line of the code above (Pheeno myRobot = Pheeno(1);). Here the class has been named myRobot, but it can be called whatever you would like when creating your own code. From this point onwards it will be assumed this instance of the class will be named myRobot. myRobot.SETUP() In the setup section of the Arduino you should include Pheeno.Setup. This function initializes all of the pins on the Arduino correctly and begins certain timers for controllers. Sensor Reading Functions myRobot.readIR() This function takes a reading from all 6 of the IR sensors and converts the measurement to cm. These values are stored in the following variables. myRobot.LDistance (The distance received by the Left IR.) myRobot.LFDistance (The distance received by the Left Forward IR.) myRobot.CDistance (The distance received by the Center IR.) myRobot.RFDistance (The distance received by the Right Forward IR.) myRobot.RDistance (The distance received by the Right IR.) myRobot.BDistance (The distance received by the Back IR.) readEncoders() This function returns the current count for the right and left encoder. This subroutine uses the Encoder.h library provided. More information on this library can be found here. These counts are stored in the variables, myRobot.encoderCountL (The count of the left encoder.) myRobot.encoderCountR (The count of the right encoder.) Pheeno.readCompass(float magNorthOffset) This function returns the current heading in degrees from magnetic north in a range of 0° to 359°. The measurement is done with respect to Pheeno’s x-axis as defined in Figure 2. Positive rotation is CCW. The argument given allows the user to input the difference between magnetic north and their desired axis. This allows the function to return the robot’s heading with respect to a given axis. If an argument of 0 is given, the function will return Pheeno’s heading with respect to magnetic north. If an argument of 10 is given, the function will return Pheeno’s heading with respect to an axis 10 degrees CCW of magnetic north. The output is stored in the variable, myRobot.IMUOrientation Figure 2: The axis of the IMU on Pheeno. Pheeno.readAccel() This function returns the accelerometer readings in the x, y, and z directions. These axis with respect to the robot may be seen in Figure 2. The sensor’s measurements are output in cm s. The output is stored in the variables, myRobot.IMUACCX (The acceleration in the x direction.) myRobot.IMUACCY (The acceleration in the y direction.) myRobot.IMUACCZ (The acceleration in the z direction.) Position Update Functions Pheeno.encoderPositionUpdate(float timeStep) This is a function that figures out where Pheeno is in space using only the encoder measurements as feedback. The function requires, as input, the time between function calls to calculate how far it has gone in that time. The update is based on the unicycle model (a kinematic model) and will accumulate error over time due to unavoidable wheel slipping and assumption errors from the model. Pheeno.sensorFusionPositionUpdate(float timeStep, float northOffset) This is a function that figures out where Pheeno is in space using all of the onboard odometry. The update is based on the unicycle model (a kinematic model). Using a complementary filter, the magnetometer and encoder measurements are used to determine Pheeno’s global orientation and the accelerometer and encoders are used to determine Pheeno’s linear displacement. The encoder measurements are high pass filtered in this function while the accelerometer and compass measurements are low pass filtered. The gains for this filter can be altered in the Pheeno.cpp file. This function requires the time step between function calls (for the encoder estimate updates) and the offset between magnetic north and a desired axis (if the user requires). Individual Motor Functions The input of all the following functions, motorSpeed, is a in arduino PWM units which are integers ranging from 0-255. 0 means no motion while 255 is as fast as it can go. These are all open loop. It is advised to put controllers over these. One is provided below! myRobot.forwardL(int motorSpeed): Rotates the left motor forward. myRobot.forwardR(int motorSpeed): Rotates the right motor forward. myRobot.reverseL(int motorSpeed): Rotates the left motor backwards. myRobot.reverseR(int motorSpeed): Rotates the right motor backward Dual Motor Functions The input of all the following functions, motorSpeed, is a in arduino PWM units which are integers ranging from 0-255. 0 means no motion while 255 is as fast as it can go. These are all open loop. Due to individual differences in the motors, construction of the robot, or the environment there could be errors in the desired motion (i.e. forward will not drive perfectly straight). myRobot.forward(int motorSpeed): Rotates both motors forwards at the same speed. myRobot.reverse(int motorSpeed): Rotates both motors backwards at the same speed. myRobot.turnRight(int motorSpeed): Rotates both motors in opposite directions at the same speed such that Pheeno rotates to its right (clockwise). myRobot.turnLeft(int motorSpeed): Rotates both motors in opposite directions at the same speed such that Pheeno rotates to its left (counter clockwise). Stopping Functions Pheeno.noMotion(): Stops the motion of both motors but still allows passive rotation. Pheeno.brake(): Brakes both motors which does not allow passive rotation (this can be overcome with enough torque). Controller Functions PIDMotorControl(float desLVel, float desRVel) This is a standard PID controller that maintains the speed of the left and right motors. The inputs are the desired right and left wheel angular velocities in rad s. The controller has been designed around a 0.05 second time step. The gains of the system can be changed in the Pheeno.cpp file if so desired. PIDWayPointControl(float u1, float u2, float desVelocity, float timeStep) This is a standard PID controller moves Pheeno from its current location to a new desired location. The PID controller maintains Pheeno’s heading in the correct direction while driving at a desired velocity. The inputs are the desired global X-Position (cm), desired global Y-Position (cm), desired linear velocity (cm s), and the time step (ms) of the controller. The controller has been designed around a 0.1 second time step. The gains of the system can be changed in the Pheeno.cpp file. rotateAboutICC(float R, float WSpeed) This function drives Pheeno in a circle of a given radius at a desired angular speed. The inputs of the function are R the radius of the desired circle (cm), WSpeed (rad s) the desired angular speed the circle is traversed. The function uses the PIDMotorControl function described in PIDMotorControl section. Calibrating Pheeno’s IMU Manual Calibration For manual calibration open the script ManualValuesIMU.ino in the Arduino folder in the GitHub repository for Pheeno. To understand the calibration routine used in the following scripts, this is an Arduino script that will print out the accelerometer and magnetometer values. This script should be used if the EEPROM can no longer store information, to understand how the calibration is done, or to get the magnetic north offset used in other scripts. Once uploading the script do not unplug the USB cord from the computer. Turn on the robot and open the serial monitor in the Arduino software. There should be numbers scrolling across the screen like in Figure 3. The first set of numbers under the “Magnetometer!” line are two vectors of the min and max readings of the magnetometer along the {x, y, z} axis. The second set of numbers under “Accelerometer!” are the averaged accelerometer measurements along the x, y, z axis. The last set of numbers under “Orientation!” is the current direction the robot has measured facing with respect to magnetic north (in degrees!). To use this script, place the robot where the experiment will take place without disconnecting it from the computer. Turn on the robot, open the serial monitor, and let it sit still for a period of time. During this time the accelerometer values are being averaged. These values will be non zero due to the natural slant of the ground or the orientation of the IMU mounted in the Pheeno robot. After a good amount of time has passed (~30 seconds), record the accelerometer values. These will be the biases you subtract off your readings to get an unbiased reading during your experiments. Next pick up Pheeno and rotate the robot about its three axis. Do this several times. When you place it back on the ground you should notice the vectors under the Magnetometer have changed. Record these values. These are the max and min values of the magnetic field in your experimental space and allow for Pheeno to better predict its heading with respect to magnetic north. The orientation in this script is just to give an idea on how well the compass is calibrated with default values. Spin Pheeno 90 degrees and see if the angle does change by about 90 degrees. Now that you have recorded the values open ManualInputEEPROM.ino. This script writes the values you have recorded to the EEPROM of the Arduino. The EEPROM of the Arduino is like a mini hard drive where you can save data that won’t be erased when the power to the robot is lost (very useful for calibration data!). Insert the data you have written down in the correct spots of the code (described below). Figure 3: The serial output of the CalibrateIMU script. This paragraph briefly describes the ManualVluesIMU.ino code shown below. Lines 2 and 3 import the correct libraries used to get data from the LSM303D IMU onboard the robot. Lines 6 and 7 set up the LSM303 library for the rest of the script creating two vectors to store the max and min values for the magnetometer. Lines 9 to 11 contain variables that store the acceleration mean values. Line 13 creates a counter to help with the acceleration means. The setup first starts the serial port with a bit rate of 9600. Then sets up the two libraries that were imported. Line 25 increments the count variable. Line 26 gets new updated data from the LSM303D. Lines 30 to 36 update the min and max values of the magnetometer vector. Lines 40 to 42 update the mean of the acceleration variables. Lines 45 to 59 simply format and perform the prints that occurs through the serial. * This script is used to calibrate the Pheeno robot's IMU. Instructions for use can be found in the Pheeno Robot Programming Guide. * include \"Wire.h\" include \"LSM303.h\" LSM303 compass; LSM303::vector&lt;int16_t&gt; running_min = {32767, 32767, 32767}; LSM303::vector&lt;int16_t&gt; running_max = {-32768, -32768, -32768}; float accX = 0; float accY = 0; float accZ = 0; float count = 0; char report[80]; void setup() { Serial.begin(9600); Wire.begin(); compass.init(); compass.enableDefault(); } void loop() { count = count + 1; compass.read(); Compass Max and Min running_min.x = min(running_min.x, compass.m.x); running_min.y = min(running_min.y, compass.m.y); running_min.z = min(running_min.z, compass.m.z); running_max.x = max(running_max.x, compass.m.x); running_max.y = max(running_max.y, compass.m.y); running_max.z = max(running_max.z, compass.m.z); Acceleration Mean accX = (count - 1) count * accX + 1 count * compass.a.x; accY = (count - 1) count * accY + 1 count * compass.a.y; accZ = (count - 1) count * accZ + 1 count * compass.a.z; snprintf(report, sizeof(report), \"min: %+6d, %+6d, %+6d max: %+6d, %+6d, %+6d\", running_min.x, running_min.y, running_min.z, running_max.x, running_max.y, running_max.z); Serial.println(\"Magnetometer!\"); Serial.println(report); Serial.println(\"Accelerometer!\"); Serial.print(int(accX)); Serial.print(\", \"); Serial.print(int(accY)); Serial.print(\", \"); Serial.println(int(accZ)); Serial.println(\"Orientation!\"); Serial.println(360-compass.heading()); Serial.println(); } This paragraph briefly describes the ManualValuesIMU.ino code shown below. Lines 3 and 4 import the libraries used for storing the calibration data. Line 8 should have the values in the {} changed to the ones recorded in ManualValuesIMU.ino. These are your max and min magnetometer readings that are used to determine the robot’s orientation. Lines 11 to 13 should have their values changed to the accelerometer values recorded earlier. All the values entered above should be integers! The rest of the code simply stores all of these values into the EEPROM. * This script is used to calibrate the Pheeno robot's IMU. Stores the values in the EEPROM. * include \"LSM303.h\" include \"EEPROM.h\" LSM303 compass; Input Compass Values Here! LSM303::vector&lt;int16_t&gt; running_min = {32767, 32767, 32767}, running_max = {-32768, -32768, -32768}; Input Accelerometer Values Here! int accX = 0; int accY = 0; int accZ = 0; int eeAddress = 0; void setup() { Store Values to the EEPROM EEPROM.put(eeAddress, int(accX)); eeAddress += sizeof(int); EEPROM.put(eeAddress, int(accY)); eeAddress += sizeof(int); EEPROM.put(eeAddress, int(accZ)); eeAddress += sizeof(int); Store Values to the EEPROM EEPROM.put(eeAddress, running_min.x); eeAddress += sizeof(int); EEPROM.put(eeAddress, running_min.y); eeAddress += sizeof(int); EEPROM.put(eeAddress, running_min.z); eeAddress += sizeof(int); Store Values to the EEPROM EEPROM.put(eeAddress, running_max.x); eeAddress += sizeof(int); EEPROM.put(eeAddress, running_max.y); eeAddress += sizeof(int); EEPROM.put(eeAddress, running_max.z); eeAddress += sizeof(int); } void loop() { } EEPROM Automatic Calibration To calibrate Pheeno automatically, open the script AutomaticCalibrateIMU.ino in the Arduino folder in the GitHub repository for Pheeno. This script does essentially what the manual script described above does(“Manual Calibration” section). To use this calibration program, upload the script then place Pheeno in the arena you wish to run the experiment in. Turn on the robot, it should sit still for about a minute then rotate for another minute. Once it has stopped moving it should be calibrated! * This script is used to calibrate the Pheeno robot's IMU. Stores the values in the EEPROM. * include &lt;Wire.h&gt; include &lt;LSM303.h&gt; include &lt;EEPROM.h&gt; LSM303 compass; LSM303::vector&lt;int16_t&gt; running_min = {32767, 32767, 32767}, running_max = {-32768, -32768, -32768}; float accX = 0; float accY = 0; float accZ = 0; float count = 1; int eeAddress = 0; Pin Numbers Here const uint8_t IRC = 0; Analog input center sensor const uint8_t IRLF = 1; Analog input left forward sensor const uint8_t IRL = 2; Analog input left sensor const uint8_t IRB = 3; Analog input back sensor const uint8_t IRRF = 6; Analog input right forward sensor const uint8_t IRR = 7; Analog input right sensor const uint8_t PWMA = 11; A Motor PWM Control const uint8_t PWMB = 5; B Motor PWM Control const uint8_t AMotor1 = 9; A Motor Direction 1 const uint8_t AMotor2 = 10; A Motor Direction 2 const uint8_t BMotor1 = 7; B Motor Direction 1 const uint8_t BMotor2 = 6; B Motor Direction 2 const uint8_t STBY = 8; Standby pin to turn off motors. const uint8_t interruptL = 3; const uint8_t interruptR = 2; const uint8_t noInterruptL = 12; const uint8_t noInterruptR = 13; void setup() { Wire.begin(); compass.init(); compass.enableDefault(); } void loop() { for(int i = 0; i&lt;1000; i++){ compass.read(); Acceleration Mean accX = (count - 1) count * accX + 1 count * compass.a.x; accY = (count - 1) count * accY + 1 count * compass.a.y; accZ = (count - 1) count * accZ + 1 count * compass.a.z; count = count + 1; } Store Values to the EEPROM EEPROM.put(eeAddress, int(accX)); eeAddress += sizeof(int); EEPROM.put(eeAddress, int(accY)); eeAddress += sizeof(int); EEPROM.put(eeAddress, int(accZ)); eeAddress += sizeof(int); turnRight(100); for(int j = 0; j&lt;5000; j++){ compass.read(); Compass Max and Min running_min.x = min(running_min.x, compass.m.x); running_min.y = min(running_min.y, compass.m.y); running_min.z = min(running_min.z, compass.m.z); running_max.x = max(running_max.x, compass.m.x); running_max.y = max(running_max.y, compass.m.y); running_max.z = max(running_max.z, compass.m.z); } Store Values to the EEPROM EEPROM.put(eeAddress, running_min.x); eeAddress += sizeof(int); EEPROM.put(eeAddress, running_min.y); eeAddress += sizeof(int); EEPROM.put(eeAddress, running_min.z); eeAddress += sizeof(int); Store Values to the EEPROM EEPROM.put(eeAddress, running_max.x); eeAddress += sizeof(int); EEPROM.put(eeAddress, running_max.y); eeAddress += sizeof(int); EEPROM.put(eeAddress, running_max.z); eeAddress += sizeof(int); while (true){ noMotion(); } } void noMotion(){ Turns the motors off. (They can still rotate passively) digitalWrite(STBY, LOW); Motors OFF } void forwardL(int motorSpeed){ Left motor drive forward. if (motorSpeed&gt;255) { motorSpeed=255; } if (motorSpeed&lt;0) { motorSpeed=0; } digitalWrite(STBY, HIGH); Motors ON analogWrite(PWMA, motorSpeed); Speed digitalWrite(AMotor1, LOW); digitalWrite(AMotor2, HIGH); } void reverseR(int motorSpeed){ Right motor drive backwards. if (motorSpeed&gt;255) { motorSpeed=255; } if (motorSpeed&lt;0) { motorSpeed=0; } digitalWrite(STBY, HIGH); Motors ON analogWrite(PWMB, motorSpeed); Speed digitalWrite(BMotor1, HIGH); digitalWrite(BMotor2, LOW); } void turnRight(int motorSpeed){ reverseR(motorSpeed); forwardL(motorSpeed); } Checking the EEPROM Calibration If you want to make sure the calibration information was stored correctly, open the EEPROMReadCalibrateData.ino script. Upload it to Pheeno and keep the robot connected to the computer. You do not need to turn on the robot as the computer can power the Arduino. If you open the serial monitor in the Arduino software, you should see a printout like the one seen in Figure 4. The numbers should be integers (definitely) and non-zero (most likely). If not something in the calibration has gone wrong. Figure 4: The serial output of the EEPROMReadCalibrateData.ino script. Pheeno Arduino Examples This section describes the specific Arduino examples below. To open any of the examples below, open the Arduino software then navigate to File –&gt; Examples –&gt; Pheeno –&gt; EXAMPLE. OpenLoopMotionExample.ino This code is meant as an intro to making Pheeno move around using open loop motor functions. Here open loop just means there is no check to make sure the wheels are doing what you want them to. When this script is uploaded to Pheeno and it is turned on it should drive forward, turn right, turn left, then drive backwards and stop. It should (in theory) start and stop at the same location. However, in reality this will not be the case the longer it runs. Lines 4 and 5 are just the normal includes that are needed when using the Pheeno library. The setup uses the standard Pheeno library setup to initialize pins correctly and start timers. Inside the loop are where all the functions occur. To drive the robot forward, line 13 uses Pheeno.forward(150). This causes both wheels on the robot to spin forward. The 150 argument can be thought of as a speed. The argument in these parenthesis is an Arduino PWM integer ranging from 0-255 where 0 is stopped and 255 is the fastest the robot can go. Once this argument is given, the wheels will continue to spin this way until a different command is given. The delay(5000) on line 14 keeps any other functions from being called for 5000 ms (5 seconds). This means the robot will drive forward for 5 seconds. NOTE: BE VERY CAREFUL WHEN USING DELAYS IN OTHER CODE, THEY STOP EVERYTHING IN THE SCRIPT MEANING NO SENSORS CAN BE READ AND CONTROLLERS WILL NOT BE UPDATED!. The rest of the script follows a similar pattern to cause the robot to turn right and left, then back up and stop. Since this is in a loop, this will keep repeating until you turn the robot off or upload a different code. * This script gives an introduction to making Pheeno drive open loop. There is no feedback, motors move at the given input but can be prone to errors in manufacturing and environment. Everything will be done with delays, however, it should be noted you cannot use delays if you require sensor feedback. * If you want to use Pheeno's premade routines import this! #include \"Pheeno.h\" The argument is the type of robot (0 = Original DD, 1 = Tank Treads, 2 = Tripod DD) Pheeno myRobot = Pheeno(0); void setup(){ This must be included in every script! It sets up all the pins on the robot! myRobot.SETUP(); } void loop(){ myRobot.forward(150); Pheeno drives forward. delay(5000); Wait for 5 seconds myRobot.turnRight(70); Pheeno turns right. delay(2000); Wait for 2 seconds. myRobot.turnLeft(70); Pheeno rotates left. delay(2000); Wait for 2 seconds. myRobot.reverse(150); Pheeno drives backwards. delay(5000); Wait for 5 seconds myRobot.brake(); Brake the motors. delay(3000); Wait for 3 seconds. } PIDMotorControlExample Now if you want some feedback when using the motors, this script uses a function that actually checks if the motors are moving at the speed you have given to them. Lines 4 and 6 import the libraries needed to use the Pheeno library. Line 8 sets the desired velocity you want the robot to move at. This is in cm s and can be changed to move the robot slower or faster. Line 12 converts the linear velocity to a rotational one that the controller acts on. The setup uses the standard setup and the loop uses the PIDMotorControl function described in the “PIDMotorControl” section. * This script gives an introduction to using encoder feedback on Pheeno's motors. In this code we will make Pheeno drive straight at a given velocity. A premade PID controller has been made to control the individual motor speeds and can be accessed using the Pheeno.PIDMotorControl() function. The PID feedback relies solely on the encoders so wheel slip can cause to robot to diverge from a straight line path! The gains of the PID can be adjusted in the Pheeno.cpp file. * If you want to use Pheeno's premade routines import this! #include \"Pheeno.h\" The argument is the type of robot (0 = Original DD, 1 = Tank Treads, 2 = Tripod DD) Pheeno myRobot = Pheeno(0); The linear velocity we want the robot to go in cm s float desVel = 10; void setup(){ This must be included in every script! It sets up all the pins on the robot! myRobot.SETUP(); Converts the linear velocity to rotational velocity for the controller. desVel = desVel * 2 myRobot.wheelDiameter; } void loop() { myRobot.PIDMotorControl(desVel, desVel); } RandomWalkExample The random walk example simply makes the robot move around in a random walk. * This script gives an introduction to making Pheeno drive a random walk. It uses delays and Arduino PWM units (int, 0-255) for speed. * If you want to use Pheeno's premade routines import these libraries!! #include \"Pheeno.h\" The argument is the type of robot (0 = Original DD, 1 = Tank Treads, 2 = Tripod DD) Pheeno myRobot = Pheeno(0); void setup() { This must be included in every script! It sets up all the pins on the robot! myRobot.SETUP(); } void loop(){ Randomly generate the ms of delay for the turn. float turnDelayTime = random(0,2000); if (random(0,2) &lt; 1){ The arduino random function is inclusive on the lower bound and exclusive on the upper bound. Thus this randomly generates 0 and 1 and creates a coin flip whether to move left or right. Pheeno rotates left about its center at a given speed (range 0 to 255). myRobot.turnLeft(150); Wait a random amount of time defined above. delay(turnDelayTime); } else { Pheeno rotates right about its center at a given speed (range 0 to 255). myRobot.turnRight(150); Wait a random amount of time defined above. delay(turnDelayTime); } ms of delay for the run (you can make this random if you desire!). float runDelayTime = 1000; Pheeno moves forward at a given speed (range 0 to 255). myRobot.forward(120); Wait a random amount of time defined above. delay(runDelayTime); } SerialPrintSensors This reads all the sensors on the robot and prints them out through the serial port. To use this, upload this script to the robot, turn on the robot, then, while the robot is still attached to the computer, open the serial monitor. The sensor values should be output. * This script constantly reads Pheeno's onboard sensors and prints their results through the serial port. * If you want to use Pheeno's premade routines import this! #include \"Pheeno.h\" The argument is the type of robot (0 = Original DD, 1 = Tank Treads, 2 = Tripod DD) Pheeno myRobot = Pheeno(0); A delay time to make manually reading the serial port easier! float delayTime = 500; void setup(){ Starts the serial port, with the argument being the bit rate. Serial.begin(9600); This must be included in every script! It sets up all the pins on the robot! myRobot.SETUP(); Serial.println(\"A test read of all Pheeno's sensors!\"); } void loop() { Reads all of the IR sensor distances in cm. myRobot.readIR(); Reads how many total ticks have occured on the encoders. myRobot.readEncoders(); Reads the compass. The argument is the offset between your global x-axis and magnetic north. myRobot.readCompass(0); Reads the accelerometer. myRobot.readAccel(); Serial.println(\"IR Sensor Distances!\"); Serial.println(\"[Left IR, Left Forward IR, Center IR, Right Forward IR, Right IR, Back IR]\"); Serial.print(\"[\"); Serial.print(myRobot.LDistance); Serial.print(\", \"); Serial.print(myRobot.LFDistance); Serial.print(\", \"); Serial.print(myRobot.CDistance); Serial.print(\", \"); Serial.print(myRobot.RFDistance); Serial.print(\", \"); Serial.print(myRobot.RDistance); Serial.print(\", \"); Serial.print(myRobot.BDistance); Serial.println(\"]\"); Serial.println(\"Encoder Counts!\"); Serial.println(\"[Left Encoder, Right Encoder]\"); Serial.print(\"[\"); Serial.print(myRobot.encoderCountL); Serial.print(\", \"); Serial.print(myRobot.encoderCountR); Serial.println(\"]\"); Serial.println(\"IMU Measurements (Accelerometer and Magnetometer Compass)!\"); Serial.println(\"[X Acceleration, Y Acceleration, Z Acceleration, Heading]\"); Serial.print(\"[\"); Serial.print(myRobot.IMUACCX); Serial.print(\", \"); Serial.print(myRobot.IMUACCY); Serial.print(\", \"); Serial.print(myRobot.IMUACCZ); Serial.print(\", \"); Serial.print(myRobot.IMUOrientation); Serial.println(\"]\"); Serial.println(); Serial.println(); A simple delay to make manual reading of the serail port easier. delay(delayTime); } DriveCircleExample This example causes Pheeno to drive in a circle of radius R such that it traverses the circle at w rad s. * This script gives an introduction to making Pheeno turn with encoder feedback. This uses the same PID controller as PIDMotorControlExample. In this example Pheeno will drive in a circle of radius R at angular speed w. * If you want to use Pheeno's premade routines import this! #include \"Pheeno.h\" Pheeno myRobot = Pheeno(0); The angular velocity Pheeno will traverse the circle (rad s)! CCW direction is positive velocity! float desW = 3.14; The radius of the circle Pheeno will be on (cm). float R = 10; void setup(){ This must be included in every script! It sets up all the pins on the robot! myRobot.SETUP(); } void loop(){ The inputs to this function are: (Desired Radius (cm), Desired Angular Velocity (rad s)). myRobot.rotateAboutICC(R, desW); } RandomWalkObstacleAvoidExample This function does the same random walk as done in the RandomWalkExample section but does not use delays so it can read the IR range sensors to avoid obstacles during the walk. * This script gives an introduction to making Pheeno drive a random walk. While doing the random walk, it will avoid obstacles. * If you want to use Pheeno's premade routines import these libraries!! #include \"Pheeno.h\" The argument is the type of robot (0 = Original DD, 1 = Tank Treads, 2 = Tripod DD) Pheeno myRobot = Pheeno(0); Distance in CM at which Pheeno will avoid obstacles. float rangeToAvoid = 10; Compare time in ms we will base our while loops off of. Initialized in the set up! float compareTime; void setup(){ This must be included in every script! It sets up all the pins on the robot! myRobot.SETUP(); Compare time in ms we will base our while loops off of. compareTime = millis(); } void loop(){ Randomly generate the ms of delay for the turn. float turnDelayTime = random(0,2000); if (random(0,2) &lt; 1){ The arduino random function is inclusive on the lower bound and exclusive on the upper bound. Thus this randomly generates 0 and 1 and creates a coin flip whether to move left or right. Pheeno rotates left about its center at a given speed (range 0 to 255). myRobot.turnLeft(150); Wait a random amount of time defined above. while(millis() - compareTime &lt; turnDelayTime){ avoidObstacles(); } compareTime=millis(); } else { Pheeno rotates right about its center at a given speed (range 0 to 255). myRobot.turnRight(150); Wait a random amount of time defined above. while(millis() - compareTime &lt; turnDelayTime){ avoidObstacles(); } compareTime=millis(); } ms of delay for the run (you can make this random if you desire!). float runDelayTime = 1000; Pheeno moves forward at a given speed (range 0 to 255). myRobot.forward(120); Wait a random amount of time defined above. while(millis() - compareTime &lt; runDelayTime){ avoidObstacles(); } compareTime=millis(); } void avoidObstacles(){ myRobot.readIR(); Speed at which to rotate away from collisions (In arduino PWM units (int, 0 to 255)). int collisionRotateSpeed = 150; if (myRobot.CDistance &lt; rangeToAvoid){ if(abs((myRobot.RDistance - myRobot.LDistance) &lt; 5 || (myRobot.RDistance &gt; rangeToAvoid &amp;&amp; myRobot.LDistance &gt; rangeToAvoid)) ) { if(random(0,2) &lt; 1) { myRobot.turnLeft(collisionRotateSpeed); } else { myRobot.turnRight(collisionRotateSpeed); } } if (myRobot.RDistance &lt; myRobot.LDistance) { myRobot.turnLeft(collisionRotateSpeed); } else { myRobot.turnRight(collisionRotateSpeed); } } else if (myRobot.RFDistance &lt; rangeToAvoid &amp;&amp; myRobot.LFDistance &lt; rangeToAvoid) { if(random(0,2) &lt; 1){ myRobot.turnLeft(collisionRotateSpeed); } else { myRobot.turnRight(collisionRotateSpeed); } } else if (myRobot.RFDistance &lt; rangeToAvoid) { myRobot.turnLeft(collisionRotateSpeed); } else if (myRobot.LFDistance &lt; rangeToAvoid) { myRobot.turnRight(collisionRotateSpeed); } else if (myRobot.LDistance &lt; rangeToAvoid) { myRobot.turnRight(collisionRotateSpeed); } else if (myRobot.RDistance &lt; rangeToAvoid) { myRobot.turnLeft(collisionRotateSpeed); } } WayPointEncoders This script makes Pheeno drive a square of side 75 cm. It uses encoder feedback to determine its global position. If you wish Pheeno to drive to different way points simply change the array in lines 13 and 14. * This script makes Pheeno drive to different way points using only encoder feedback! * If you want to use Pheeno's premade routines import this! #include \"Pheeno.h\" The argument is the type of robot (0 = Original DD, 1 = Tank Treads, 2 = Tripod DD) Pheeno myRobot = Pheeno(0); Time step for the odometry update to operate at (10Hz)! float timeStep = 100; Iterator through the way points. int count = 0; Desired linear velocity of Pheeno in cm s. float desVel = 10; --- WayPoint Path Points --- Pheeno's array of waypoint x positions. float botYf[4]={0,0,75.0000,75.00}; Pheeno's array of waypoint y positions. float botXf[4]={0,75.0000,75.0000,0}; Number of waypoints entered. int numWayPoints = (sizeof(botXf) sizeof(float)); void setup(){ This must be included in every script! It sets up all the pins on the robot! myRobot.SETUP(); } void loop() { while (calculateDistance(myRobot.botXPos,myRobot.botYPos, botXf[count%numWayPoints], botYf[count%numWayPoints]) &gt; 3){ myRobot.PIDWayPointControl(botXf[count%numWayPoints],botYf[count%numWayPoints],desVel,timeStep); Encoders used for state estimates. myRobot.encoderPositionUpdate(timeStep); } count ++; } float calculateDistance(float x1, float y1, float x2, float y2){ Calculates the distance the robot is from the desired way point float space = sqrt(sq((x1 - x2)) + sq((y1 - y2))); return space; } wayPointSensorFusion This also makes Pheeno drive in a square of side 75 cm but uses a complementary filter for sensor fusion for updating the robots global position. The robot should be calibrated before this script is run! * This script makes Pheeno drive to different way points using a complementary filter on the magnetometer, accelerometer, and encoders for feedback! * If you want to use Pheeno's premade routines import this! #include \"Pheeno.h\" The argument is the type of robot (0 = Original DD, 1 = Tank Treads, 2 = Tripod DD) Pheeno myRobot = Pheeno(0); Time step for the odometry update to operate at (10Hz)! float timeStep = 100; Iterator through the way points. int count = 0; Desired linear velocity of Pheeno in cm s. float desVel = 15; Difference between magnetic north and the global X axis float northOffset = 12.9; --- WayPoint Path Points --- Pheeno's array of waypoint x positions. float botYf[4]={0,0,75.0000,75.00}; Pheeno's array of waypoint y positions. float botXf[4]={0,75.0000,75.0000,0}; Number of waypoints entered. int numWayPoints = (sizeof(botXf) sizeof(float)); void setup(){ This must be included in every script! It sets up all the pins on the robot! myRobot.SETUP(); } void loop() { while (calculateDistance(myRobot.botXPos,myRobot.botYPos,botXf[count%numWayPoints],botYf[count%numWayPoints]) &gt; 3){ myRobot.PIDWayPointControl(botXf[count%numWayPoints],botYf[count%numWayPoints],desVel,timeStep); Encoders used for state estimates. myRobot.sensorFusionPositionUpdate(timeStep, northOffset); } count ++; } float calculateDistance(float x1, float y1, float x2, float y2){ Calculates the distance the robot is from the leader float space = sqrt(sq((x1 - x2)) + sq((y1 - y2))); return space; }"
					}

					
				
			
		
			
				
					,
					

					"pheeno-pheeno-software-installation": {
						"id": "pheeno-pheeno-software-installation",
						"title": "Pheeno Software Installation",
						"category": "",
						"url": " /pheeno/pheeno_software_installation/",
						"content": "Installation Currently, Pheeno files can run on all major platforms (Windows, Linux, and OS X) all that is required is cloning the repository to your system. git clone https: github.com ACSLab PheenoRobot.git The following dependencies programs are required to use these files: OpenCV Arduino IDE pySerial picam NOTE: This should be a default package on the Raspberry Pi. NumPy NOTE: The SciPy stack is rather difficult to install on a Windows environment. This guide may help. Make sure to install all the dependencies for each version part of the SciPy stack! Tkinter NOTE: Tkinter is typically installed by default. If it is not, please refer to the link about for installation instructions. Currently, Python 2.7+ is the only supported platform. Getting these files to work Python 3 is possible if one was able to install OpenCV on Python 3. Full Python 3 compatibility will be implemented as soon as an OpenCV Python 3 implementation is made stable. Getting Started This section will give a brief introduction to installing the Arduino program to your computer, uploading a script to Pheeno, and installing the pre-made libraries onto your computer. Installing Arduino If you do not have the Arduino software on your computer, first go to the Arduino software download page. Download the appropriate software for your operating system and install it! Installing the Pheeno Libraries To use the pre-made libraries for Pheeno you must first download the files and place them in the right place on your computer so the Arduino software can access them. From the GitHub repository for Pheeno download the Code folder. Inside this folder should be an Arduino subfolder with folders labeled Encoder, LSM303, and Pheeno. Copy those folders to your “Documents Arduino libraries” folder. Now open the Arduino software. If all was done correctly, when you go to ‘File –&gt; Examples’, you should see ‘Encoder’, ‘LSM303’, and ‘Pheeno’ at the bottom (you may have to scroll down if you have a lot of Arduino libraries already)! If this does not work or the above instructions are unclear, it is recommended to look through the Arduino Library Guide."
					}

					
				
			
		
			
				
					,
					

					"pheeno-raspberry-pi-content": {
						"id": "pheeno-raspberry-pi-content",
						"title": "Setting Up Raspberry Pi with Camera for Pheeno",
						"category": "",
						"url": " /pheeno/raspberry_pi_content/",
						"content": "Unboxing, Formatting, and Installing the Operating System for the Pi First, credit should be given where credit is due. Most of the networking information comes from A Raspberry Pi-Controlled Robot; Building a Rover with Python, Linux, Motors, and Sensors by Wolfram Donat. This was done on an older version of the Pi so some of the information have changed things here and there but the source of a lot of this information is from this book. It is a very good source for starting out in robotic control with a Raspberry Pi. Formatting the SD card to install the OS on the Raspberry Pi The Raspberry Pi is essentially a Linux computer and will not work straight out of the box. We need to install an operating system that will run on-board the Pi. To do this we will need a micro SD card (4GB or larger, 8GB is preferred) and a SD card reader on your personal computer. Note, if your computer does not have a SD card reader you can easily find a USB adapter to plug into your machine. A quick startup guide can be found here. If this link is down or you do not have access to this PDF on a computer, the process will be summarized below. Insert the SD card into your computer. Note: I did this on a Windows machine so I would recommend that route. Format the SD card to make sure it is clean and ready for the OS to be installed. Download the SD Association’s formating tool (SD Formatter 4.0) from here for the operating system you are using (Windows or Mac). Install and run the formatting tool. Check that the drive you have selected matches your SD card (it would be really unfortunate if you formatted a different drive and erased all those files.) Format the drive. Download the New Out Of Box Software (NOOBS!) here. Extract the files in the NOOBS Zip you downloaded to the formatted SD card. Eject the SD card from your computer after the files have finished transferring and plug it into the Raspberry Pi. Hook the Raspberry Pi up to a keyboard, mouse, and monitor. Then insert the USB power cable to turn the Pi on. The Pi should now boot into NOOBS and display a list of operating systems. If it doesn’t you did something wrong with the formatting or file copy go back and reformat the SD! If this works, FANTASTIC, that little board is now a fully functioning computer! There should be a list of operating systems you can install. Click Raspbian (the tick box next to the icon should have an x in it). Now click install. Go grab a drink or some food! The operating system is now installing. This can take a while (about 20 minutes). When the install process is completed the Raspberry Pi configuration menu (raspi-config) will load. Here you are able to set the time and date for your region and enable a Raspberry Pi camera board, or even create users. We can access this at a later date to make changes as we need but for now let’s just enable the camera! Upon rebooting, it will boot straight to the command line requesting a login. The default username and password are pi and raspberry respectively. Note: you will not see any writing appear when you type the password. This is a standard linux security feature. To start the graphical interface (desktop) type startx. Making Sure the Camera Works! Again, a great guide with video is here. Again below will summarize the steps to making sure the camera works! First let’s physically install the camera board.Make sure your Pi is off when installing! The flex cable has gray connector strips on the back side. Behind the Ethernet port is a black plastic connector this goes into. Lift the plastic tabs on the side of this connector to unlock the connector. Insert the flex cable so the tin connectors are facing away from the ethernet port and are level. Push the plastic tabs back down so the wire is locked in place. When done, the setup should look like Figure 1. Great now the camera is physically installed! Figure 1: Raspberry Pi with camera board installed. Now we can fully connect the Raspberry Pi again. Make sure it is connected to the internet by plugging in an ethernet chord or connecting via wifi. When it boots open the command terminal and upgrade the firmware to the latest version through the commands: sudo apt-get update sudo apt-get upgrade Now we will let the Pi know we want it to use the camera pins. In the command terminal type: sudo raspi-config to bring up the configuration settings for the Pi. Go to the Enable Camera option. Choose the enable option. Select finish and reboot the Pi! Now everything should be ready to take a picture so lets try! First, go to the graphical user interface (type startx at the terminal). To test it open the command terminal (seen in Figure 2) and type: raspivid -t 10000 Figure 2: Raspberry Pi graphical user interface with LXTerminal highlighted. This should have displayed a picture on the monitor for 10 seconds (note the units of the argument after the -t are in ms). Hopefully it all worked! Installing Software and VNC In this section we will set up a VNC (Virtual Network Computing) server in order to access the graphical user interface of the Pi remotely instead of constantly having to hook it up to a monitor. We will auto configure the wifi so the pi is connected to a network (not necessarily one with internet connection!). Make sure a WiFi dongle is plugged into a USB port on the Pi! We will also install some other supplemental software needed for image processing. If you do not know how to hook up the Pi to an internet network it is detailed below but you still need to access the internet for updates upgrades so either skip to the GUI network configuration first or plug in an ethernet cord to get the Pi online! Setting Up the WiFi Connection It is important to note unlike a standard Windows, Linux, or Mac operating system, Raspbian does not notify you of updates. Thus, it is a good habit to force your Pi to look for updates whenever installing new software (ideally daily but that may be overkill). Thus before doing anything bring up the terminal and update and upgrade the Pi through the commands: sudo apt-get update sudo apt-get upgrade Now, we can configure the network through the terminal or the GUI, I will outline both below. Terminal Network Set-Up Once the upgrade is complete, first install wpasupplicant (Note: This may already be installed). sudo apt-get install wpasupplicant You may get a message saying wpasupplicant is already in the newest version, that is fine. Once it is installed use any text editor to open the network config file (here we use nano which will open it in the terminal): sudo nano etc wpa_supplicant wpa_supplicant.conf Here is where you put the network information. Leave the first two lines of the file as they are, then add: network={ ssid=\"_your network id_\" psk=\"_your network key_\" proto=WPA key_mgmt=WPA-PSK pairwise=TKIP authalg=OPEN } Replace “your network id“ and “your network key“ with your network name and key (the network key is the password that has been set on the network to log into it from any device). It should be noted, if you care about security, this does leave your network name and key in a plain text file for any half-decent hacker to find and use. Save the file and reboot your Pi for the changes to take place. sudo shutdown -r now When the Pi reboots, you should have a wireless connection! GUI Network Set-UP In the top right of the desktop of the Pi you will see a wifi icon. Click it, choose your network you want to connect to and enter the passkey! Easy as that (but not quite as cool as editing a config file right?!). Check Connection Now to make sure the Pi is connected to the internet bring up the terminal and type: ifconfig This displays all your internet connections! You should see three connections listed eth0, lo, and wlan0. Eth0 is your ethernet cable connection if you have one, wlan0 is the one that should have just been configured. If there is an IP address WOO HOO the Pi is connected to the internet. To make sure try connecting to your favorite web page (if your network has an internet connection and isn’t a LAN) Creating a Static IP on the Network In order to connect to your Pi you must know it’s “name”. Imagine your Pi as another person. If you want to get their attention from across the room you typically have to yell their name. This is where a Static IP address comes in! Think of a Pi’s IP address as its name (this is true for any network device). The funny thing about computers on a network is they can change their IP address whenever they connect, thus we have to set the Pi’s IP address so when we try to connect to it we call it the right “name” to get its attention. If you don’t care for this metaphor you are going to have to do this anyway! First we need some information about your connection. In the terminal enter: ifconfig Again this should list some connection information, eth0, lo, wlan0. We are attempting to create a static IP on the wireless network thus take note of several details about the wlan0. We are interested in (write these down!), inet addr - the Pi’s current IP address. Bcast - the broadcast IP range. Mask - the subnet mask address. We need a little more information to finish this up. So now, in the terminal, enter, netstat-nr We are interested in (write down the ones that are not 0.0.0.0), Gateway Destination Now the config file can finally be edited to gives a static IP! Let’s open it to be edited in the terminal by entering, sudo nano etc network interfaces You should get something that looks like this, auto lo iface lo inet loopback auto eth0 allow-hotplug eth0 iface eth0 inet manual auto wlan0 allow-hotplug wlan0 iface eth0 inet manual wpa-config etc wpa_supplicant wpa_supplicant.conf It may have some additional entries but that should be what it looks like for the most part. Again, if you are worried about security, the wpa_supplicant.conf has the network information and password in a plain text file that can be read very easily. Now let’s enter the information for our static IP! Edit the file so that it looks like this! auto lo iface lo inet loopback auto eth0 allow-hotplug eth0 iface eth0 inet manual auto wlan0 allow-hotplug wlan0 iface eth0 inet static address ”_the static IP address_” netmask ”_the netmask found above_” network ”_the network found above_” broadcast ”_the broadcast found above_” gateway ”_the gateway found above_” wpa-config etc wpa_supplicant wpa_supplicant.conf Exit and save the file! Now reboot the Pi, sudo shutdown -r now To see if everything worked open the terminal and type, ifconfig Under wlan0 the IP address should be the one you set! Now to test the connection type, ping \"_the gateway found above_\" If everything if configured correctly you should get a few printouts that read, 64 bites from ”_the gateway found above_”: icmp_req:1 ttl=64 time=1.24ms If all of that works CONGRATS you have now set a static IP! We will soon be able to access the Pi remotely! Setting Up Secure Shell (SSH) and Virtual Network Computing (VNC) SSH Secure Shell allows us to remotely log into the raspberry pi but only in a terminal setting. However, you will notice everything we have done has been through the terminal so this is invaluable. We will first enable this on the Pi! In the terminal enter, sudo raspi-config Under Advanced Options select SSH and enable. That’s it! Now onto your PC. For SSH I use Putty to connect (on windows). Putty can be downloaded here. Now simply run it and enter the static IP address you created earlier! It should prompt you with, login as: \"_the username for the pi (default is pi)_\" pi@: \"_the IP address of the Pi_\" password: \"_the password for the pi (default is raspberry)_\" Now you should be logged into the terminal of the Pi! Note: This can be done on Linux as well by using the command, ssh -l pi \"_the IP address of the Pi_\" VNC Virtual Network Computing (VNC) is useful for those less Linux savy. It allows for the user to see the desktop of the Pi instead of the terminal. The terminal and other programs may still be accessed like you were logged straight into the Pi. However, some things, like video streams, might not work as if you were hooked straight into the machine. This is simple enough to install. On the Pi open the terminal and enter, sudo apt-get install tightvncserver This installs TightVNC, which is possibly the easiest VNC package to get running. Once it is installed you can start the server with a command line, vncserver :1 -geometry 1024x768 -depth 16 On your personal computer install a VNC client. I recommend realVNC found here. You may have to enter some information for a free key which is good for 5 computers. To connect to the Pi through VNC enter, \"_the IP address of the PI_\":1 You can get this to start on boot. However, it is probably better to ssh in and start the server when needed. Setting Up an Ad Hoc Network Now let’s pretend we don’t live in a perfect world where we always have a network connection we can talk to each other through. What if we’re bringing Pheeno out to an unknown environment or to some school outreach event? What if we don’t have a network to connect to the Raspberry Pi through? Are we finished?! Fear not for the Raspberry Pi can become a server of an Ad Hoc Network! We don't want to do this unless we are taking Pheeno (or the Raspberry Pi) out of the lab. Once again we have to edit the interfaces file! I would STRONGLY recommend making two files saved somewhere. One for when you are in the lab, and one when you are in the field. None the less again we must edit the interfaces file, sudo nano etc network interfaces We want to edit the wireless section again so it looks like the following, auto wlan0 iface wlan0 inet static address \"_some IP address (192.168.119.1)_\" netmask \"_some netmask (255.255.255.0)_\" wireless-channel 1 wireless-essid \"_some name for the broad casted network_\" wireless-mode ad-hoc Save the file and exit. Then restart the wireless connection, sudo ifdown wlan0 sudo ifup wlan0 Now you should be able to see the network being broadcast. Do not connect to it. It is not ready to receive connections. It is simply broadcasting it’s ad-hoc network but will not assign IP addresses to any computer connecting to it. We need to set up the Pi to assign IP addresses. First we will install isc-dhcp-server, sudo apt-get install isc-dhcp-server Now we have to edit the config file to get it to work! Open the config file with the command, sudo nano etc dhcp dhcpd.conf There is a TON of stuff in this file. You want the only uncommented lines to be (changes in red), ddns-update-style interim; default-lease-time 600; max-lease-time 7200; authoritative; log-facility local7; subnet \"_some subnet similar to the IP address (192.168.119.0)_\" netmask \"_some netmask (255.255.255.0)_\" { range \"_some range of assignable IP address (192.168.119.5 192.168.119.100)_\"; } Here is an example of what it may look like, # # Sample configuration file for ISC dhcpd for Debian # # # The ddns-updates-style parameter controls whether or not the server will # attempt to do a DNS update when a lease is confirmed. We default to the # behavior of the version 2 packages ('none', since DHCP v2 didn't # have support for DDNS.) ddns-update-style interim; # option definitions common to all supported networks... #option domain-name \"example.org\"; #option domain-name-servers ns1.example.org, ns2.example.org; default-lease-time 600; max-lease-time 7200; # If this DHCP server is the official DHCP server for the local # network, the authoritative directive should be uncommented. authoritative; # Use this to send dhcp log messages to a different log file (you also # have to hack syslog.conf to complete the redirection). log-facility local7; # No service will be given on this subnet, but declaring it helps the # DHCP server to understand the network topology. #subnet 10.152.187.0 netmask 255.255.255.0 { #} # This is a very basic subnet declaration. subnet 192.168.119.0 netmask 255.255.255.0 { range 192.168.119.5 192.168.119.100; } #subnet 10.254.239.0 netmask 255.255.255.224 { # range 10.254.239.10 10.254.239.20; # option routers rtr-239-0-1.example.org, rtr-239-0-2.example.org; #} # This declaration allows BOOTP clients to get dynamic addresses, # which we don't really recommend. #subnet 10.254.239.32 netmask 255.255.255.224 { # range dynamic-bootp 10.254.239.40 10.254.239.60; # option broadcast-address 10.254.239.31; # option routers rtr-239-32-1.example.org; #} # A slightly different configuration for an internal subnet. #subnet 10.5.5.0 netmask 255.255.255.224 { # range 10.5.5.26 10.5.5.30; # option domain-name-servers ns1.internal.example.org; # option domain-name \"internal.example.org\"; # option routers 10.5.5.1; # option broadcast-address 10.5.5.31; # default-lease-time 600; # max-lease-time 7200; #} # Hosts which require special configuration options can be listed in # host statements. If no address is specified, the address will be # allocated dynamically (if possible), but the host-specific information # will still come from the host declaration. #host passacaglia { # hardware ethernet 0:0:c0:5d:bd:95; # filename \"vmunix.passacaglia\"; # server-name \"toccata.fugue.com\"; #} # Fixed IP addresses can also be specified for hosts. These addresses # should not also be listed as being available for dynamic assignment. # Hosts for which fixed IP addresses have been specified can boot using # BOOTP or DHCP. Hosts for which no fixed address is specified can only # be booted with DHCP, unless there is an address range on the subnet # to which a BOOTP client is connected which has the dynamic-bootp flag # set. #host fantasia { # hardware ethernet 08:00:07:26:c0:a5; # fixed-address fantasia.fugue.com; #} # You can declare a class of clients and then do address allocation # based on that. The example below shows a case where all clients # in a certain class get addresses on the 10.17.224 24 subnet, and all # other clients get addresses on the 10.0.29 24 subnet. #class \"foo\" { # match if substring (option vendor-class-identifier, 0, 4) = \"SUNW\"; #} #shared-network 224-29 { # subnet 10.17.224.0 netmask 255.255.255.0 { # option routers rtr-224.example.org; # } # subnet 10.0.29.0 netmask 255.255.255.0 { # option routers rtr-29.example.org; # } # pool { # allow members of \"foo\"; # range 10.17.224.10 10.17.224.250; # } # pool { # deny members of \"foo\"; # range 10.0.29.10 10.0.29.230; # } #} Python and OpenCV Pheeno uses OpenCV for its image processing and I have chosen to code in Python (as C C++ get too messy for me). To finish the set up for the Pi let’s install OpenCV for python and make sure it runs. Again make sure the firmware is updated and upgraded, sudo apt-get update sudo apt-get upgrade Now we will grab the libraries for OpenCV. sudo apt-get install libopencv-dev python-opencv python-picamera -y To test whether everything is working properly let’s create a quick python code with OpenCV to display some windows with the camera feed and mess with their colors! Make a new python code and save it in the home folder as cameraDisplay.py. Open this empty file and fill it with, import picamera import picamera.array import cv2 #CAMERA ROUTINE! with picamera.PiCamera() as camera: with picamera.array.PiRGBArray(camera) as stream: camera.resolution = (640,480) while True: camera.capture(stream,'bgr',use_video_port = True) #stream.array contains the image array in bgr order! gray = cv2.cvtColor(stream.array, cv2.COLOR_BGR2GRAY) HSV = cv2.cvtColor(stream.array, cv2.COLOR_BGR2HSV) cv2.imshow('Video!', stream.array) cv2.imshow('GRAY!', gray) cv2.imshow('HSV!', HSV) if cv2.waitKey(1) &amp; 0xFF == ord('q'): break #reset the array for next capture stream.seek(0) stream.truncate() cv2.destroyAllWindows() To run it open the terminal and enter, python cameraDisplay.py Three windows should pop up and show the camera feed with different color schemes (RGB, Gray Scale, and HSV). If that works, YOU'RE DONE! The Pi should be ready to go and be used however you see fit!"
					}

					
				
			
		
	};
</script>
<script src="/scripts/lunr.min.js"></script>
<script src="/scripts/search.js"></script>

			</article>
		</section>

		<script>
			document.getElementById("open-nav").addEventListener("click", function () {
				document.body.classList.toggle("nav-open");
			});
		</script>
	</body>
</html>
